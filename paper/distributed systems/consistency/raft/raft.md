# Raft

## 基础概述

一个`Raft`集群包括若干服务器。服务器一定会处于以下三种状态中的一种：

+ `跟随者/Follower`：跟随者是被动的，它们不会发送任何请求，只是响应来自领导者和参选者的请求。

+ `参选者/Candidate`：参选者是参加选举领导者的一台服务器。它是由在一段时间内没有收到任何消息的跟随者转变成的。

+ `领导者/Leader`：领导者处理所有来自客户端的请求。领导者在它们宕机之前会一直保持领导者的状态。

时间被分为一个个任意不同长度的`任期Term`，每一个任期的开始都是领导者选举。任期用连续的数字进行表示。

基本的`Raft`一致性算法仅需要 2 种`RPC`。

+ `RequestVote RPC`是参选者在选举过程中触发的。

+ `AppendEntries RPC`是领导者触发的，为的是复制日志条目和提供一种`心跳（Heartbeat）机制`。

## 领导选举

### 流程概述

`Raft`使用一种心跳机制来触发领导选举。

当服务器启动时，它们会初始化为跟随者。

+ 如果它能收到来自领导者或参选者的有效`RPC`（任期需要大于跟随者所保存的任期），它就会一直保持跟随者状态；

+ 当跟随者收到参选者的`RequestVote RPC`，它会比较任期大小来选择是否投票。

+ 反之，它就认为选举超时，并自增它当前的任期转化成参选者。

+ 接着，它给自己投票并且给集群中的其他服务器发送`RequestVote RPC`开始新一轮选举。

一个参选者会一直保持参选状态直到以下三种情况发生：

+ 它获得多数选票赢得选举，向其他服务器发送`RPC`确立领导者地位；

+ 另一台服务器赢得选举，收到其他服务器发送的`RPC`退化成跟随者；

+ 它既没有赢得选举，也没有输掉选举，开启新一轮选举。（`Raft`使用随机的选举超时时间来减少这种情况发生）

### 常见问题

多次选举：如果参选者始终只能平分选票，那么整个集群就会陷入选举死循环。

`Raft`算法通过随机选举超时时间来解决多次选举的问题。

多领导者：如果原领导者和其他服务器连接断开，新一轮选举开始选出一个新的领导者，此时就是多个领导者共存。

旧领导者重新加入集群：

## 日志复制

一旦选出了 Leader，它就开始接收客户端的请求。

每一个客户端请求都包含一条需要被复制状态机（Replicated State Machine）执行的命令。Leader 把这条命令作为新的日志条目加入到它的日志中去，然后并行的向其它服务器发起 AppendEntries RPC，要求其它服务器复制这个条目。

每个日志条目存储着：

+ 一条被状态机执行的命令；

+ 当这条日志条目被 Leader 接收时的任期号；

+ 一个整数索引来表示它在日志中的位置。

Raft 保证可已提交

的日志条目是持久化的，并且最终会被所有可用的状态机执行。

一旦被 Leader 创建的条目已经复制到了大多数的服务器上，这个条目就称为已提交的。

Leader 日志中之前的条目都是已提交的，包括由之前的 Leader 创建的条目。

## Reference

+ [raft extended](https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf)

+ [raft 动画演示](http://www.kailing.pub/raft/index.html)

+ [gitbook 寻找一种易于理解的一致性算法](https://knowledge-sharing.gitbooks.io/raft/content/)
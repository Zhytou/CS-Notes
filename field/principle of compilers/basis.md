# 编译原理基础

- [编译原理基础](#编译原理基础)
  - [编译器](#编译器)
    - [编译器组成](#编译器组成)
    - [编译流程](#编译流程)
  - [编译优化](#编译优化)
    - [内存栅栏](#内存栅栏)
    - [内联函数](#内联函数)
    - [gcc优化](#gcc优化)
  - [其他编译相关概念](#其他编译相关概念)
    - [静态库和动态库](#静态库和动态库)
    - [编译型和解释型](#编译型和解释型)
    - [及时编译和提前编译](#及时编译和提前编译)
    - [RTTI](#rtti)
  - [参考](#参考)

## 编译器

编译器是一种将高级语言源代码转换为目标机器可执行代码的程序。

### 编译器组成

编译器通常由两个主要组件组成：前端和后端。其中，前端主要负责将高级语言源代码进行词法分析、语法分析、语义分析等操作，生成中间代码或汇编语言代码；而后端负责将中间代码或汇编语言代码翻译为目标机器的机器代码。

以gcc（GNU Complier）来说，它针对每种语言都有相应的前端，例如：C预处理器：cpp、C编译器：cc1、C++预处理器：cpp、C++编译器：cc1plus，但它在默认情况下，只使用gas（GNU Assembler）作为后端，将中间代码转换为机器码。最后使用gld（GNU Linker）将目标文件和相关的库文件进行链接，生成可执行程序或者共享库等。

### 编译流程

一般来说，将源文件生成目标文件的流程通常包括以下四个步骤：

- 预处理：在这个阶段，主要是处理头文件包含、宏替换、条件编译等预处理指令，生成一个新的临时文件，通常以.i或者.ii作为扩展名，这个文件包含了所有的预处理结果。
- 编译：在这个阶段，编译器会将预处理后的代码进行一系列词法分析、语法分析、语义分析及优化，最终生成汇编代码，通常以.s作为扩展名。
- 汇编：在这个阶段，汇编器会将汇编代码转换为机器码，生成目标文件，通常以.o作为扩展名，这个目标文件包含了可执行代码、符号表、调试信息等。
- 链接：在这个阶段，链接器会将目标文件和相关的库文件进行链接，生成可执行程序或者共享库等。链接器会将不同的目标文件组合起来，解决符号引用、重定位等问题，生成最终的可执行程序或共享库。

## 编译优化

### 内存栅栏

内存栅栏是一种硬件指令，用于确保特定的内存操作按照指定的顺序执行，防止编译器和处理器的优化导致数据可见性问题。内存栅栏分为读屏障(Load Barrier)和写屏障(Store Barrier)，可以防止指令重排序。例如，mfence指令在x86架构中用于实现全内存屏障，确保在屏障前后的读写操作按照正确的顺序执行。

**内存栅栏在编程语言中的体现——std::memory_order**：

除此之外，内存栅栏和原子类型同样有一定关联。比如：C++ STL库提供了std::memory_order这个枚举类型来指定std::atomic类操作内存的顺序，而其底层则正是依赖于内存栅栏所实现的。具体来说，std::memory_order包括：

- std::memory_order_relaxed（松散顺序）：不对执行顺序做出任何保证。
- std::memory_order_consume（消费顺序）：一个载入操作的后续操作（仅限于依赖于该载入操作的结果的操作）不能被重排到该载入操作之前。
- std::memory_order_acquire（获取顺序）：一个载入操作的后续操作（包括对任何变量的读取和写入）不能被重排到该载入操作之前。
- std::memory_order_release（释放顺序）：一个存储操作的前序操作（包括对任何变量的读取和写入）不能被重排到该存储操作之后。
- std::memory_order_acq_rel（获取释放顺序）：同时包含 std::memory_order_acquire 和 std::memory_order_release 的语义。
- std::memory_order_seq_cst（顺序一致顺序）：除了有 std::memory_order_acq_rel 的语义外，还保证了全局的顺序一致性。

### 内联函数

内联函数是一种编程技术，它可以在编译器对函数进行调用时将函数的代码直接插入到调用位置，而不是通过函数调用的方式执行。这样可以减少函数调用的开销，提高程序的执行效率。但是如果内联函数逻辑较复杂，则可能会导致代码膨胀，增加程序的体积。因此，对于函数体较小或者频繁调用的函数适合使用内联函数。

在C++中，使用inline关键字声明内联函数，并将其定义在头文件中，尤其是多个源文件需要使用该内联函数时。因为内联函数会在编译时被标记出来，在链接时实际替换。此外，虽然使用inline关键字可以提示编译器将函数内联，但最终是否内联还是由编译器决定。编译器会根据函数的复杂度、调用情况等因素来决定是否进行内联优化。

### gcc优化

## 其他编译相关概念

### 静态库和动态库

**静态库**：

- 静态库对函数库的链接是放在编译时期完成的。
- 程序在运行时与函数库再无瓜葛，移植方便。
- 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。

**动态库**：

- 动态库把对一些库函数的链接载入推迟到程序运行的时期。
- 可以实现进程之间的资源共享。（因此动态库也称为共享库）
- 将一些程序升级变得简单。
- 甚至可以真正做到链接载入完全由程序员在程序代码中控制（**显示调用**）。

### 编译型和解释型

**编译型语言**是指在程序执行之前，将源代码一次性编译成机器码，生成可执行文件。在运行时，计算机直接执行机器码，无需再进行编译。常见的编译型语言包括C、C++等。编译型语言的优点是执行速度快，但缺点是跨平台性差，需要针对不同平台进行编译。

**解释型语言**是指程序在运行时逐行解释执行，无需一次性编译成机器码。解释型语言的源代码直接由解释器逐行翻译成机器码并执行。常见的解释型语言包括Python、JavaScript等。解释型语言的优点是跨平台性好，缺点是执行速度相对较慢。

### 及时编译和提前编译

**及时编译（Just-In-Time, JIT）**是一种混合编译技术，将源代码先编译成中间代码，在运行时使用即时编译器将中间代码编译成机器码执行。JIT编译可以在运行时根据程序的执行情况进行优化，提高程序的执行效率。常见的使用JIT编译的语言包括Java、C#等。

**提前编译（Ahead Of Time, AOT）**是指在程序执行之前，将源代码一次性编译成机器码，生成可执行文件。它通常用于对性能要求较高的部分代码或整体。

### RTTI

在C++中，运行时类型信息（Run-Time Type Information, RTTI）是一种特性。它允许程序在运行时获取对象的类型信息。具体来说，主要通过下列两者方式实现：

- **dynamic_cast**用于将基类指针或引用转换为派生类指针或引用。如果转换合法，则返回转换后的指针或引用，否则返回nullptr。
- **typeid**用于获取对象的类型信息。它返回一个type_info对象，包含了对象的实际类型信息。

**RTTI原理**：

想要搞清楚RTTI背后的原理，首先需要复习虚表的内存分布，因为dynamic_cast的功能就决定了RTTI和虚表多态的紧密联系。关于这一点的详细介绍可以查看[陈皓-虚表解析](https://blog.csdn.net/haoel/article/details/1948051)。

![type info内存分布](https://i-blog.csdnimg.cn/blog_migrate/65206a0cf4a3c9af21289f0e63bbf166.jpeg)

根据上图可知，RTTI的实现依赖于虚表中第一项指向一个type_info类。

## 参考

- [stack over flow - JIT vs Interpreters](https://stackoverflow.com/questions/3718024/jit-vs-interpreters)
- [编译优化，编译器到底做了什么？](https://juejin.cn/post/6933180767656738824)

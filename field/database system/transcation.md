# 数据库事务

- [数据库事务](#数据库事务)
  - [事务模型](#事务模型)
    - [ACID](#acid)
    - [BASE](#base)
  - [并发与隔离](#并发与隔离)
    - [并发问题](#并发问题)
    - [隔离级别](#隔离级别)
  - [故障恢复与日志](#故障恢复与日志)
    - [预写式日志机制](#预写式日志机制)
    - [恢复算法 ARIES](#恢复算法-aries)
    - [MySQL日志](#mysql日志)
  - [并发控制](#并发控制)
    - [锁](#锁)
    - [MVCC](#mvcc)

数据库事务是数据库运行中的逻辑工作单位，单个逻辑工作单元所执行的一系列操作，要么都执行，要么都不执行。

**事务状态**：

![事务状态](../img/database_transaction_state.png)

- 活动：初始状态；事务在执行时保持此状态
- 部分提交：在某些情况下，一个事务可能包含多个独立的操作，这些操作可以被分成多个阶段进行提交。
- 失败：发现无法继续正常执行后。
- 中止：事务回滚后，数据库恢复到事务开始前的状态。中止后有两个选项：
  - 重新启动事务：只有在没有内部逻辑错误的情况下才能完成
  - 终止事务：
- 已提交 – 成功完成后。

## 事务模型

ACID和BASE是两种不同的数据库事务模型，它们确定数据库组织和操作数据的方式。ACID数据库优先考虑一致性而不是可用性，如果事务中的任何步骤出现错误，整个事务都会失败。相比之下，BASE数据库优先考虑可用性而不是一致性。用户可以暂时访问不一致的数据，而不是让事务失败。数据一致性可以实现，但不能立即实现。

一般来说，关系型数据库往往遵从ACID特性，而分布式数据库则遵从BASE特性。

### ACID

**原子性 Atomicity**：事务的原子性指的是，事务中包含的程序作为数据库的逻辑工作单位，它所做的对数据修改操作要么全部执行，要么完全不执行。这种特性称为原子性。

**一致性 Consistency**：事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。这种特性称为事务的一致性。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。

**隔离性 Isolation**：分离性指并发的事务是相互隔离的。即一个事务内部的操作及正在操作的数据必须封锁起来，不被其它企图进行修改的事务看到。假如并发交叉执行的事务没有任何控制，操纵相同的共享对象的多个并发事务的执行可能引起异常情况。

**持久性 Durability**：持久性意味着当系统或介质发生故障时，确保已提交事务的更新不能丢失。即一旦一个事务提交，DBMS保证它对数据库中数据的改变应该是永久性的，即对已提交事务的更新能恢复。持久性通过数据库备份和恢复来保证。

> Atomicity, isolation, and durability are properties of the database, whereas consis‐ tency (in the ACID sense) is a property of the application. The application may rely on the database’s atomicity and isolation properties in order to achieve consistency, but it’s not up to the database alone. ---DDIA

值得一提的是，原子性，隔离性和持久性是数据库的属性，而一致性是应用程序的属性。以MySQL为例，它通过undo log保证原子性，通过lock和MVCC保证隔离性，通过redo log保证持久性，最终得到一致性。换句话说说AID是手段，C是目的！

### BASE

**基本可用性 Bascially Available**：系统在出现故障或异常情况时仍然能够保证基本的可用性，即使在部分功能受限的情况下。

**软状态 Soft State**：这意味着系统的状态可以随着时间而改变，即使没有输入。

**最终一致性 Eventual Consistency**：系统允许在不同节点之间存在短暂的数据不一致，但最终会达到一致状态。

## 并发与隔离

### 并发问题

在典型的应用程序中，多个事务并发运行。若不添加适当的并发控制，则往往会造成以下问题。

**脏读**：事务A读到了事务B未提交的数据。

**不可重复读**：事务A第一次查询得到一行记录row1，事务B提交修改后，事务A第二次查询同样得到row1，但列内容发生了变化。

**幻读**：事务A第一次查询得到一行记录row1，事务B提交修改后，事务A第二次查询得到两行记录row1和row2。

### 隔离级别

根据使用并发控制程度不同，可用获得不同的事务隔离性，如下图所示。

![database ioslation](../img/database_ioslation.png)

## 故障恢复与日志

数据库中可能发生各种各样的故障，它大致可分为以下几类：

- 事务内部故障：它是指非预期的、不能由应用程序处理的故障，如运算溢出、死锁等。它意味着事务没有正确到达预期终点——COMMIT或显式ROLLBACK。因此，恢复该故障需要在不影响其他事务的情况下，撤销该事务已经对数据库做出的所有修改，即事务撤销(UNDO)。
- 系统故障：它是指造成系统停止运转需要重启的任何事件，如断电、操作系统故障等。这类故障影响正在运行的所有事务，但不破坏数据库。为了保证系统的数据一致性，恢复程序除了要撤销所有未完成的事务外，还需要重做(REDO)所有已提交事务。
- 介质故障：它包括磁盘损坏、磁头碰撞等。这类故障发生可能性很小，但对数据库的破坏性最大。

数据库的恢复很简单，可用一个词概括：冗余。也就是说，数据库中任何一部分被破坏或不正确的数据都可以根据存储在系统别处的冗余数据来重建。常见的建立冗余数据方法包括：冗余存储和日志。

**影子分页**：

影子分页技术(Shadow Paging)是一种常见的冗余存储手段。它是一种写时复制技术，以避免原地修改页面。当一个页面将被修改，一个影子页面被分配。由于影子页面没有被别的地方引用，可以自由修改，不必顾虑一致性。当影子页面变得可以持久，所有引用原页面的地方都被修改为引用影子页面。由于影子页面直到修改完毕才被激活，这保证了原子性。

**数据库日志**：

在数据库系统中，日志一般指定就是事务日志(Transcation Log)。它用于记录事务的修改操作，以便在系统崩溃或异常情况下进行恢复或重做。对于关系型数据库来说，日志和并发控制是其保证ACID特性的重要机制；而对于分布式数据库来说，多节点、基于分布式日志的一致性算法和节点复制是其保证BASE的特性的机制。可见，日志在数据库系统的重要性。

关于日志和影子分页技术两者的对比，可以查看这篇文章[Write-ahead logs and shadow paging](https://misfra.me/wal-and-shadow-paging/)。

**日志组成**：

数据库日志记录一般由以下部分组成：

- 日志序列号(Log Sequence Number, LSN)：日志记录的唯一ID。使用LSN，可以在恒定时间内恢复日志。大多数LSN都按单调递增顺序分配，这在恢复算法中很有用。
- 上一个LSN：指向其最后一个日志记录的链接。这意味着数据库日志以链接列表形式构建。
- 事务ID号：对生成日志记录的数据库事务的引用。
- 类型：描述数据库日志记录的类型。
- 有关触发写入日志记录的实际更改的信息。

### 预写式日志机制

实际上，采用日志来实现事务原子性和持久性的数据库都实现了一种名为预写式日志(Write-Ahead Logging, WAL)的机制。它指的所有数据的修改在生效之前都要先写入日志文件中。

**数据缓存Buffer Pool**：

为了提高存储效率并减少磁盘I/O次数，几乎所有数据库都在主存中开辟了一块内存用作磁盘中数据页缓存。以InnoDB为例，它设计了Buffer Pool用于存储数据页和索引页，且读写操作均直接作用于该缓存。显然，它是一种易失性存储(Volatile Storage)，即断电就丢失数据的存储器。因此，为了避免在系统断电后丢失Buffer Pool中还没落盘的脏数据或事务内部故障导致操作仅部分完成的情况，存储引擎需要先将日志持久化，从而获得重做和撤销的能力，即实现了名为预写式日志的机制。

**重做和回滚Redo & Undo**：

WAL通过两个步骤来实现原子性和持久性，分别是：

- 重做：对所有已经提交的事务，根据日志重新执行记录的修改操作，确保事务的所有影响都已经持久化到磁盘。
- 回滚：对于未完成的事务，根据日志将其已修改的部分撤销，回滚到事务开始前的状态。

**日志缓存Log Buffer**：

和普通数据一样，日志也由类似缓存管理器以页为单位刷入磁盘。它也可以采用不同的持久化策略，包括：

- No-Force：允许事务commit没有输出到稳定存储器的更改。
- Steal：允许没有commit的块输出到磁盘策略。

尽管都是写入磁盘，但和写入数据记录相比，写入日志明显速度更快。因为写入日志只是追加操作，所以磁盘操作是顺序写，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是随机写。换句话说，这是WAL的一个优势：将磁盘随机写转为了顺序写。

**检查点Checkpoint**：

检查点，也叫完全或同步检查点，是数据库定期将Buffer Pool中的脏页全部写入磁盘并更新日志的状态点。这减少了恢复时需要处理的日志量，提高了恢复速度，但完全检查点会阻塞数据库中其他事务，对系统性能造成较大影响。

**模糊检查点Fuzzy Checkpoint**：

模糊检查点，也称为非阻塞检查点，是一种优化策略。它不要求一次性将全部脏页刷入磁盘，而是间写入部分脏页，以平衡性能和恢复时间。

### 恢复算法 ARIES

恢复和隔离利用语义算法(Algorithms for Recovery and Isolation Exploiting Semantics, ARIES)是一种数据库故障恢复算法。它使用WAL和CheckPoint机制，在遭遇系统故障时，它会重做已提交事务并撤销未提交事务。此外，它还会将撤销事务时对数据库所做更改记录下来，以避免在重新启动时再次重复此操作。一般来说，ARIES分为以下三个阶段：

- 分析(Analysis)：确定哪些事务在故障发生时是活动的。
- 重做(Redo)：根据日志重做已提交事务的修改。
- 回滚(Undo)：撤销未提交事务的修改。

### MySQL日志

MySQL中最重要的日志包括重做日志(redo Log)、回滚日志(undo log)和归档日志(binlog)三类。其中，前两者由InnoDB存储引擎层生成，分别实现了原子性和持久性，即WAL日志；后者由Server层生成，主要用于数据备份和主从复制。

**回滚日志的分类**：

回滚日志由InnoDB存储引擎生成，用于在事务回滚时恢复数据到事务开始前的状态。它分为以下三类：

- 插入回滚日志 ：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。
- 更新回滚日志：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。
- 删除回滚日志：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。 值得一提的是，删除操作一般都只是设置一下老记录的DELETED_BIT，并不真正将过时的记录删除。

**回滚日志的存储**：

一条记录的每一次更新操作产生的undo log格式都有一个roll_pointer指针和一个 trx_id事务id：

- 通过trx_id可以知道该记录是被哪个事务修改的；
- 通过roll_pointer指针可以将这些undo log串成一个链表，这个链表就被称为版本链，比如。

![回滚日志版本链](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E7%89%88%E6%9C%AC%E9%93%BE.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

**归档日志和重做日志的不同之处**：

尽管归档日志和重做日志都记录了数据库的操作记录，但二者仍有不同。

- 归档日志由MySQL的Server层实现，所有存储引擎都可以使用；而重做日志仅由Innodb存储引擎实现。
- 归档日志有三种类型，分别是STATEMENT、ROW和MIXED，并以文本形式存储；而重做日志是物理日志，记录的是在某个数据页做了什么修改，比如对XXX表空间中的YYY数据页ZZZ偏移量的地方做了AAA更新。
- 归档日志是追加写，写满一个文件就创建新文件继续写；而重做日志由于检查点机制的存在是循环写。

**主从复制和归档日志**：

MySQL的主从复制依赖于binlog，也就是记录MySQL上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将binlog中的数据从主库传输到从库上。它分为三个阶段：

- 写入binlog：主库写binlog日志，提交事务，并更新本地存储数据。
- 同步binlog：把binlog复制到所有从库上，每个从库把binlog写到暂存日志中。
- 回放binlog：回放binlog，并更新存储引擎中的数据。

**归档日志的持久化**：

事务执行过程中，先把日志写到binlog cache（Server层的cache）。等到事务提交的时候，再把binlog cache刷入磁盘。值得一提的是，一个事务的binlog是不能被拆开的，因此无论这个事务有多大（比如有很多条语句），也要保证一次性写入。这是因为有一个线程只能同时有一个事务在执行的设定，所以每当执行一个begin/start transaction的时候，就会默认提交上一个事务，这样如果一个事务的binlog被拆开的时候，在备库执行就会被当做多个事务分段自行，这样破坏了原子性，是有问题的。

## 并发控制

并发控制是数据库管理系统中确保多个事务在并发执行时保持数据一致性的重要机制。常见的并发控制机制包括：

- Lock-Based Protocols：锁机制是最常见的并发控制方法，它通过在数据对象上设置不同类型的锁（如共享锁、排他锁）来控制事务的访问。
- Timestamp-Based Protocols：基于时间戳的协议为每个事务分配一个时间戳，事务按照时间戳顺序执行，避免了锁的使用。
- Validation-Based Protocols：验证协议在事务提交前检查其对数据的修改是否与并发执行的其他事务冲突。

### 锁

从锁粒度来看，锁可分为全局锁、页级锁(BDB引擎)、表级锁和行级锁；从锁定策略来看，锁可分为乐观锁和悲观锁；从锁定行为来看，锁可分为读锁/共享锁和写锁/互斥锁。其中，乐观锁和悲观锁是抽象的概念，并不对应特定的锁类型。前者认为并发时不会发生数据冲突，因此默认读操作不加锁，仅在写操作时判断数据是否发生修改。如果检测到数据冲突，则放弃写操作。而后者则认为并发时会发生数据冲突，因此读写操作均需要获取锁保证数据一致性。

**MySQL的锁**：

MySQL中锁可按粒度分为全局锁、页级锁(BDB引擎)、表级锁和行级锁。其中，仅InnoDB引擎是支持行级锁的，而MyISAM引擎并不支持行级锁。因此，关于行级锁的介绍主要放在了下一节中。本节主要介绍全局锁和表级锁。

全局锁是针对整个数据库的。当数据库被施加全局锁时，整个库就处于只读状态了，任何DML(Data Manipulation Language)和DDL(Data Definition Language)语句都会被阻塞。它主要用于全库的逻辑备份，其保证了在备份期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。

表级锁主要分为表锁(Table Lock)和元数据锁(MetaData Lock, MDL)。其中，表锁是针对整张表的。它可分为读锁和写锁，读锁可共享而写锁互斥。比如，为表t1添加锁表可以，使用如下命令：

```sql
/* 给表t1添加读锁或写锁 */
LOCK TABLES t1 READ | WRITE;
/* 释放该表锁 */
UNLOCK TABLES
```

至于元数据锁，它则用于保证表结构在并发下的数据一致性。对于DML(Data Manipulation Language)操作来说，它执行之前需要获取元数据读锁；而对于DDL(Data Definition Language)操作来说，它执行之前则需要获取元数据写锁。和表锁相比，元数据锁则不需要在SQL语句中显示调用，由MySQL自动添加和释放。

此外，InnoDB引擎还提供了两种特殊的表级锁——自增锁(Auto-Inc Lock)和意向锁(Intention Lock)。其中，自增锁主要用于管理自增列值的分配。当向表中插入数据时，就需要先获取其自增锁。通过自增锁，InnoDB能够生成一组连续的自增列值供多个并发事务无冲突地消费，从而避免了"偶然递增"或"重复分配"的现象。自增锁分为三种模式：

- 传统模式：每次为单个INSERT语句分配一个自增值，需要持有自增锁直到事务结束。
- 连续模式(MySQL5.5引入)：对于Simple Insert不使用表级锁，而是使用轻量级互斥锁生成自增值；对于Bulk Insert使用表级锁。
- 交错锁模式(MySQL8.0引入)：所有插入操作都不使用表级锁，只使用轻量级互斥锁。

InnoDB引擎提供的意向锁分为意向共享锁(Intention Shared Lock, IS)和意向互斥锁(Intention Exclusive Lock, IX)，用于指明事务稍后会对行数据进行读或写的意向。换句话说，如果事务想要在一张表上加行锁，必须先获得该表的相应意向锁。因此，可以说InnoDB支持多粒度锁定，允许行锁和意向锁共存。尽管意向锁之间不会生数据冲突，也不会和行锁发生数据冲突，但它会阻止其他事务获取表读写锁。值得一提的是，意向锁同样是由数据引擎自己维护的，用户无法使用SQL语句手动操作意向锁。

**InnoDB的锁**：

不同于其他存储引擎，InnoDB引擎实现行级锁定。而其提供的行级锁基本都可以分为共享锁(Shared Lock, S)和互斥锁(Exclusive Lock, X)，比如，共享/互斥意向锁、共享/互斥记录锁和共享/互斥临键锁。前者可同时被多个读操作事务获取，后者一次仅能被一个写操作事务获取。

另外，InnoDB引擎提供的行级锁可按锁定对象分为记录锁(Record Lock)、间隙锁(Gap Lock)、临键锁(Next-Key Lock)和插入意向锁(Insert Intention Lock)。其中，记录锁总是锁定实际数据，即在聚簇索引上加锁，即使创建表时没有显式指定主键索引。

间隙锁是锁定索引记录之间的间隙，或锁定第一个索引记录之前或最后一个索引记录之后的间隙。例如，`SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;`可防止其他事务将值15插入列t.c1，无论该列中是否已有这样的值，因为范围内所有现有值之间的间隙均已锁定。间隙可能跨越单个索引值、多个索引值，甚至为空。值得一提的是，间隙锁之间是兼容的，可以同时有多个事务获取到同一间隙锁，且它们都只能保护间隙不能被插入新值。

临键锁是记录锁和间隙锁的一个组合。它不仅锁定记录本身，还会锁定一个范围的间隙。因此，临键锁即能保护记录本身，也能阻止新纪录插入到被保护的间隙中去。

插入意向锁时一种特殊的间隙锁。一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁。如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个插入意向锁，表明有事务想在某个区间插入新记录，但是现在处于等待状态。

关于InnoDB中锁的详细介绍可以查看MySQL手册[17.7.1 InnoDB Locking](https://dev.mysql.com/doc/refman/8.4/en/innodb-locking.html)

**SQL语句与锁**：

```sql
/* 全局锁 */
/* 整个库处于只读状态 */
FLUSH TABLES WITH READ LOCK
/* 释放全局锁 */
UNLOCK TABLES

/* 表级锁 */
/* 锁定表以只读方式，不允许其他事务写入 */
LOCK TABLES ... READ
/* 锁定表以读写方式，阻止其他事务访问 */
LOCK TABLES ... WRITE
/* 释放表锁*/
UNLOCK TABLES

/* 行级锁*/
/* 对读取的记录加共享锁 */
SELECT ... LOCK IN SHARE MODE 
/* 对读取的记录加独占锁 */
SELECT ... FOR UPDATE
/* 修改操作自动加独占锁 */
```

### MVCC

多版本并发控制(Multi-Version Concurrency Control, MVCC)是MySQL中用于在可重复读和提交读两个隔离级别下实现事务并发的机制。它利用Undo Log记录数据库更改前数据，并用ReadView拍下快照，从而为后续并发读访问提供支持。换句话说，MVCC在每次修改时都保存一个快照，并关联一个时间戳。

当一个事务执行读取操作时，它会选择符合最接近其事务开始时间的一个快照进行读取，从而避免读取到其他事务修改期间的脏数据。而当一个事务执行写操作时，它会生成一个新数据版本并将修改后的数据写入数据库。

**实现原理**：

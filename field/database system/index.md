# 索引

- [索引](#索引)
  - [简介](#简介)
    - [作用](#作用)
    - [分类](#分类)
  - [实现](#实现)
  - [使用](#使用)
    - [最左匹配原则](#最左匹配原则)
    - [失效](#失效)
  - [优化](#优化)

## 简介

索引是对数据库表中一或多个列的值进行排序的结构，是帮助数据库高效获取数据的数据结构。

### 作用

索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。

### 分类

- ：B+树索引、Hash索引、Full-text索引。
- ：（主键索引）、二级索引（辅助索引）。
- ：主键索引、唯一索引、普通索引、前缀索引。
- 按字段个数分类：。

**按数据结构分类**：

从数据结构的角来看，常见的索引包括：

- B+树索引：查找、排序和分组。
- Hash索引：只能查找，且无法范围查找。
- 自适应哈希索引：InnoDB存储引擎提供了一种特殊的索引，它结合了B+树索引和Hash索引的优点。其原理就是当某个索引值被使用的非常频繁时，会在B+树索引之上再创建一个哈希索引。这样就让B+树索引具有哈希索引的一些优点，比如快速的哈希查找。

事实上，每一种存储引擎能够支持的索引都有所不同，MySQL存储引擎支持索引如下图所示。

![MySQL存储引擎支持索引](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB.drawio.png)

**按物理存储分类**：

从物理存储的角度来看，索引分为主索引/聚簇索引、辅助索引/二级索引/非聚簇索引两种。其中，主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。

因此，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是覆盖索引（比如查询的值其实就只针对该索引列）。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是回表。

**按字段特性分类**：

从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。其中，主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。比如：

```sql
CREATE TABLE table_name  (
  ....
  PRIMARY KEY (index_column_1) USING BTREE
);
```

唯一索引建立在UNIQUE字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。它的创建可以使用如下方式：

```sql
/* 创建表时，创建唯一索引 */
CREATE TABLE table_name  (
  ....
  UNIQUE KEY(index_column_1,index_column_2,...) 
);
/* 建表之后，创建唯一索引 */
CREATE UNIQUE INDEX index_name
ON table_name(index_column_1,index_column_2,...); 
```

前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为char、 varchar、binary、varbinary的列上。相比其他索引，前缀索引能有效减少索引占用的存储空间，并提升查询效率。它的创建方法如下：

```sql
/* 创建表时，创建前缀索引 */
CREATE TABLE table_name(
    column_list,
    INDEX(column_name(length))
); 
/* 建表之后，创建前缀索引 */
CREATE INDEX index_name
ON table_name(column_name(length)); 
```

普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为UNIQUE。

**按字段个数分类**：

从字段个数的角度来看，索引可以分为单列索引、联合索引。其中，建立在多列上的索引就叫联合索引，也成为复合索引。它的创建方式如下：

```sql
/* 将商品表中的 product_no 和 name 字段组合成联合索引(product_no, name) */
CREATE INDEX index_product_no_name ON product(product_no, name);
```

值得一提的是，联合索引的匹配遵循最左匹配原则，即按照左边优先的方式进行索引匹配。因此，如果不遵守最左匹配原则，索引就会失效，查询效率也会大大降低。

## 实现

**为什么采用B+树作为实现索引的数据结构？**：

**InnoDB的B+树索引**：

InnoDB 的 B-Tree 索引分为**主索引**和**辅助索引**

- 主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为==聚簇索引==
  - 因为无法把数据行存放在两个不同的地方，所以==一个表只能有一个聚簇索引==
- 辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要==先查找到主键值，然后再到主索引中进行查找==

## 使用

### 最左匹配原则

### 失效

- 查询条件中有or
- like查询是以'%'开头
- 对查询的列上有运算或者函数的
- 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
- 左连接查询或者右连接查询查询关联的字段编码格式不一样
- 如果mysql估计使用全表扫描要比使用索引快,则不使用索引

## 优化

用explain 命令查看执行计划，然后针对性的修改sql语句

这里说一下几种常见优化索引的方法：

前缀索引优化；
覆盖索引优化；
主键索引最好是自增的；
防止索引失效；
前缀索引优化

# 文件 & 文件系统

- [文件 \& 文件系统](#文件--文件系统)
  - [文件和目录](#文件和目录)
    - [文件系统API](#文件系统api)
    - [创建和挂载文件系统](#创建和挂载文件系统)
  - [文件系统](#文件系统)
    - [元数据](#元数据)
    - [磁盘空间分配](#磁盘空间分配)
    - [目录组织](#目录组织)
    - [空闲空间管理](#空闲空间管理)
    - [读取和写入](#读取和写入)
    - [缓存和缓冲](#缓存和缓冲)
  - [总结](#总结)
  - [参考](#参考)

## 文件和目录

按Unix系统的设计理念，`Everything is file!`，即：操作系统中所有资源都可以当作文件看待。比如：我们可以在`/proc`目录下看到系统当前运行的进程；我们可以通过系统提供的套接字（Socket）机制，使用类似读写文件的操作向另一条机器上运行的进程进行通信。但是，文件最重要、最基本的作用还是对块设备（持久化设备）的抽象。

### 文件系统API

常见的文件系统API包括：

- 创建和删除文件
- 读写文件
- 文件重命名
- 获取文件信息
- 创建和删除目录
- 硬链接和符号链接

**硬链接**：类似文件别名

- 硬链接是为一个现有文件创建一个新的物理引用(物理入口)
- 硬链接和原文件指向同一个物理数据,相当于给文件数据创建了一个新别名
- 删除一个硬链接并不影响原文件和其他硬链接,只有最后一个链接被删除后,文件数据才会被清除
- 硬链接只能创建于同一个文件系统内,不能链接目录
- 硬链接不能链接符号链接本身

**符号链接/软链接**：类似快捷方式

- 软链接是一个特殊的文件，其中包含指向另一个文件的路径信息
- 删除被链接的源文件，软链接将成为死链接(无法访问)
- 软链接可以跨越文件系统
- 软链接可以对目录进行链接
- 软链接可以对其他软链接进行链接

### 创建和挂载文件系统

**创建文件系统**：

为了在外接存储设备上创建一个文件系统，大多数文件系统提供了一个工具，通常名为mkfs。向mkfs提供一个设备（例如磁盘分区，例如/dev/sda1），一种文件系统类型（例如 ext3），它就在该磁盘分区上写入一个空文件系统，从根目录开始。

一旦创建了这样的文件系统之后，我们就可以通过挂载来访问磁盘上的数据。

**挂载的定义**：

挂载是指在原有的文件系统中创建一个挂载点（即目录）作为访问新文件系统的入口。因此，挂载的过程其实就是让内核建立磁盘分区的文件系统和某个目录之间的映射关系。之后对该目录的访问，实际上就是对磁盘分区数据的访问。

**需要挂载的原因**：

尽管外接磁盘在/dev目录下已经有了对应的设备文件节点(如/dev/sdb1)，但这仅表示内核已经检测到了这个磁盘设备的存在能够与之通信，但它无法直接访问设备文件。只有将磁盘分区上的文件系统挂载到某个目录之后，用户才能通过该目录访问磁盘文件系统进而访问磁盘上的数据。

## 文件系统

文件系统主要关注两方面的问题：

- 第一个方面是文件系统的数据结构（Data Structure）。换言之，文件系统在磁盘上使用哪些类型的结构来组织其数据和元数据？
- 文件系统的第二个方面是访问方法（Access Method）。如何将进程发出的调用，如 open()、read()、write()等，映射到它的结构上？在执行特定系统调用期间读取哪些结构？改写哪些结构？所有这些步骤的执行效率如何？

### 元数据

文件系统最重要的磁盘结构之一是Inode（Index Node），几乎所有的文件系统都有类似的结构。它用于描述保存给定文件的所有信息，包括：文件类型（例如，常规文件、目录等）、大小、分配给它的块数、保护信息（如谁拥有该文件以及谁可以访问它）、一些时间信息（包括文件创建、修改或上次访问的时间文件下），以及有关其数据块驻留在磁盘上的位置的信息（如某种类型的指针）。我们也称这些信息为元数据（Meta Data）。实际上，文件系统中除了纯粹的用户数据外，其他任何信息通常都称为元数据。

设计Inode时，最重要的决定之一是它如何引用数据块的位置。一种简单的方法是在Inode中有一个或多个直接指针（磁盘地址）。每个指针指向属于该文件的一个磁盘块。但这种方法难以支持寻址一个非常大的文件（例如，大于块的大小乘以直接指针数）。

**多级索引**：

为了支持更大的文件，人们提出了一种名为多级索引的方法。它的思路是在Inode中引入一种特殊的结构，即间接指针（Indirect Pointer）。间接指针它不是指向包含用户数据的块，而是指向包含更多指针的块，每个指针指向用户数据。因此，Inode可以有一些固定数量（例如12个）的直接指针和一个间接指针。如果文件变得足够大，则会分配一个间接块（来自磁盘的数据块区域），并将Inode的间接指针设置为指向它。

类似的，如果想要支持更大的文件，则可以使用双重间接指针，乃至三重间接指针。而这种不平衡树则被称为指向文件块的多级索引（Multi-level Index）方法。许多文件系统使用多级索引，包括常用的文件系统，如 Linux ext2和ext3，NetApp的WAFL，以及原始的UNIX文件系统。

**Inode号与软硬链接**：

每个Inode都有一个号码，操作系统用Inode号码来识别不同的文件。值得一提的是，Unix/Linux系统内部不使用文件名，而使用Inode号码来识别文件。对于系统来说，文件名只是Inode号码便于识别的别称或者绰号。

一般情况下，文件名和Inode号码是一一对应关系，每个Inode号码对应一个文件名。但是，Unix/Linux系统允许使用硬链接为文件创建别名。换句话说，硬链接本质上就是将多个文件名指向同一个Inode号码。而对于软链接，文件A和文件B的Inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。

### 磁盘空间分配

**磁盘分区**:

磁盘分区是使用分区编辑器（Partition editor）在磁盘上划分几个逻辑部分，盘片一旦划分成数个分区（Partition），不同类的目录与文件可以存储进不同的分区。换句话说，不同的分区中都包含一个独立的文件系统。

通过分区，我们可以将磁盘划分为多个独立的逻辑区域，每个区域都可以单独格式化成不同的文件系统(如ext4、xfs、ntfs等)。这为我们灵活组织数据、安装多个操作系统提供了基础。此外，独立分区可以使每个文件系统从属于不同的挂载点，从而实现分区挂载。这不仅便于磁盘空间管理,还可以增强文件系统的安全性和可用性。

**分区空间分配**：

每个分区都有自己的:

- 超级块(超级块记录文件系统元数据)
- Inode位图/数据块位图(标记空闲/已用)
- Inode表(存储所有文件的Inode元数据)
- 数据块区域(存储文件实际内容)

### 目录组织

一个目录基本上只包含一个二元组（子目录/文件名称，Inode号）的列表。

### 空闲空间管理

文件系统必须记录哪些Inode和数据块是空闲的，哪些不是，这样在分配新文件或目录时，就可以为它找到空间。因此，空闲空间管理（free space management）对于所有文件系统都很重要。常见的用于空闲空间管理的结构包括：位图和空闲链表等。

### 读取和写入

### 缓存和缓冲

## 总结

文件系统是基于block I/O封装的数据结构。换句话说，文件系统是建立在块，即磁盘扇区或簇输入/输出模型之上的一个数据结构。

文件系统通过映射、索引等机制把文件和目录对应到底层的磁盘块，然后通过块I/O访问实际的数据。

## 参考

- [Operating Systems: Three Easy Pieces: Files and Directories](https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/39.pdf)
- [Operating Systems: Three Easy Pieces: File System Implementation](https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/40.pdf)

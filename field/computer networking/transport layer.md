# 传输层

- [传输层](#传输层)
  - [UDP](#udp)
  - [TCP](#tcp)
    - [TCP首部](#tcp首部)
    - [三次握手](#三次握手)
    - [四次挥手](#四次挥手)
    - [可靠传输](#可靠传输)
    - [滑动窗口——流量控制](#滑动窗口流量控制)
    - [拥塞控制](#拥塞控制)
    - [其他](#其他)
  - [Socket](#socket)

## UDP

用户数据报协议UDP（User Datagram Protocol）是一种无连接的，尽最大可能交付、面向报文的传输层通信协议。它的特点包括：

- 无连接：无需维护连接状态。
- 尽最大可能交付：没有滑动窗口等机制确保可靠连接。
- 面向报文：对于应用程序传下来的报文不合并也不拆分，只是添加UDP包头。
- 多种连接方式：支持一对一、一对多、多对一和多对多的交互通信。

## TCP

传输控制协议TCP（Transmission Control Protocol）是一种面向连接的、可靠的、提供拥塞控制和流量控制的传输层通信协议。它的特点包括：

- 面向连接（字节流）：把应用层传下来的报文看成字节流，根据网络情况把字节流组织成大小不等的数据块。
- 提供可靠交付：依靠确认应答以及超时重传机制保证可靠传输。
- 有流量控制和拥塞控制：通过滑动窗口和拥塞窗口实时调整发送速率，TCP能很好适应网络拥塞情况，保证可靠高效传输。
- 仅支持支持一对一连接，无法实现广播和多播通信。
- 双工通信，即客户端和服务端都可以同时充当发送者和接收者的角色。

### TCP首部

![TCP首部](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/55dc4e84-573d-4c13-a765-52ed1dd251f9.png)

**标志位 Flag**：

TCP首部中的标志位（1 bit）用于标识TCP报文段的不同属性和状态。FIN、ACK和SYN是TCP包头中的三个重要的符号位。

- SYN（Synchronize）：SYN标志位用于建立一个TCP连接。在三次握手过程中，主动发起连接的一方会将SYN标志位置为1，表示请求建立连接。接收方收到SYN标志位后，会发送一个SYN+ACK报文作为响应，表示同意建立连接。
- FIN（Finish）：FIN标志位用于结束一个TCP连接。当发送方希望关闭连接时，会将FIN标志位置为1，通知接收方不再发送数据。接收方收到FIN标志位后，会发送一个ACK确认消息，并准备关闭连接。
- ACK（Acknowledgement）：ACK标志位用于确认收到的数据。在TCP协议中，除了用于传输数据的报文段外，还有专门用于确认的ACK报文段。ACK标志位置为1表示该报文段是一个确认报文段，用于确认接收到的数据。

指的注意的是，SYN和FIN才是相对的两个标志位，而非SYN和ACK，因为SYN用于开启TCP连接，而FIN用于关闭TCP连接。至于ACK，它在连接建立后将一直保持为1。

此外，在TCP中，SYN标志位置为1的报文，即SYN报文，不能携带数据，同时还需要消耗一个序号。类似的还有FIN报文，它即使不携带数据也需要消耗一个序号。而与之相反的则是ACK报文，尽管它也允许携带数据，但当它不携带数据时则不消耗序号。

**序号 Sequence Number**：

在TCP报文中只能够提供一个32位的区域用于存储报文序号。当报文序号超过这个范围时，序号字段将循环回零重新计数。换句话说，TCP报文中的序号只是一个相对序号。

在实际通信中，发送者会随机初始化一个32位的起始报文序号（Initial Sequence Number，ISN），并告知接收者。此时，接收者就可以通过将报文中的相对序号（Sequence Number，seqno）与起始序号相加的方式获取实际的绝对序号（Absolute Sequence Number）。这三者的关系如下：

![seqno](https://zhytou.github.io/post/2023-8-4/seqno.png)

**确认号 Acknowledgement Number**：

TCP是一种双工通信协议，这意味着其客户端和服务端都既是发送者也是接收者。这也是为什么它的首部中同时存在序号和确认号两个值。前者在其作为发送方时标识数据包的序列号，而后者则在其作为接收方时表示望接收的下一个字节的序列号。换句话说，确认号其实就是滑动窗口中第一个缺失值序号。

### 三次握手

![三次握手](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e92d0ebc-7d46-413b-aec1-34a39602f787.png)

如上图所示，客户端A主动向服务器端B建立TCP连接的流程如下：

- 首先B处于LISTEN（监听）状态，等待客户的连接请求。
- A向B发送连接请求报文（SYN=1），同时将随机初始化一个序号x。
- B收到连接请求报文，如果同意建立连接，则向A发送连接连接确认报文（SYN=1, ACK=1）。其中，确认号为x+1，而序号则为其随机初始化的一个值y。
- A收到B的连接确认报文后，还要向B发出确认，确认号为y+1，序号为x+1。
- B收到A的确认后，连接建立。

**随机初始序号的原因**：

如果每次建立连接，客户端和服务端的初始化序列号都是一样的话，很容易出现历史报文被下一个相同四元组的连接接收的问题。

**三次握手的原因**  ：

尽管在第二次握手时，客户端和服务端实际已经建立了连接，但TCP仍然设计了第三次握手来确认连接完成。这是因为第三次握手能够防止过期失效的连接请求到达服务器让服务器错误打开连接。

假设移除第三次握手，那么服务端一旦接收到SYN报文就会进入ESTABLISHED状态。此时，如果客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。尽管客户端可以通过上下文，关闭历史连接，但这仍旧造成了服务器资源浪费。因此，使用三次握手第一时间阻止失效请求建立连接是最简单有效的方法。

**第一次握手丢失**：

当客户端想和服务端建立TCP连接的时候，它会发送一个SYN报文，也就是进行第一次握手，然后进入到SYN_SENT状态。如果客户端迟迟收不到服务端的SYN-ACK报文（第二次握手），就会触发超时重传机制，重传一份序列号相同的SYN报文。它会重复上述步骤，直到超过最大重传数量限制或连接成功。值得注意的是，TCP重传机制要求每次间隔时间是上一次的两倍，用来平衡性能。

**第二次握手丢失**：

类似第一次握手丢失，当服务端的SYN-ACK报文丢失时，客户端和服务端都会进行重传，直到超过最大重传数量限制或连接成功。

**第三次握手丢失**：

第三次握手的ACK是对第二次握手的SYN的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传SYN-ACK报文，直到收到第三次握手，或者达到最大重传次数。这是因为ACK报文是不会有重传的，当ACK丢失了，就由对方重传对应的报文。

**SYN攻击**：

SYN攻击就是攻击者短时间伪造多个SYN报文，使服务器所有TCP端口都陷入ACK报文等待（即第三次握手），从而致使其无法正常工作。

应对这种攻击的方法包括：

- 减少SYN+ACK重传次数，从而使服务器尽快主动断开连接。
- 开启syncookies功能，从而在不使用SYN半连接队列的情况下成功建立连接。
- 增大TCP半连接队列，避免正常请求因半连接队列满了而丢弃。

### 四次挥手

![四次握手](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg)

如上图所示，客户端A和服务器端B断开TCP连接的流程如下：

- A发送连接释放报文（FIN=1），B收到之后发出确认。此时，TCP属于半关闭状态，B能向A发送数据但是A不能向B发送数据。
- 当B不再需要连接时，发送连接释放报文（FIN=1）。
- A收到后发出确认，进入TIME-WAIT状态，等待2*MSL（最大报文存活时间）后释放连接。
- B收到A的确认后释放连接。

**四次挥手的原因**  ：

根本原因就是TCP就是一个双工通信协议，客户端和服务端可以互相发送信息。因此，关闭这两个信道就一共需要两个FIN报文和两个ACK报文。

**MSL vs TTL**：

最大报文存活时间(Maximum Segment Lifetime, MSL)是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。而TTL是IP首部中的一个字段，它表示该IP包被路由器丢弃之前允许通过的最大网段数量，即路由跳数量。由于TCP是依赖于IP的，所以MSL往往大于TTL消耗到0的时间，以确保报文自热消亡。换句话说，假如TTL的值为64，而MSL是30秒，这就意味着该数据报文经过64个路由器的时间不会超过30秒，如果超过了，就认为报文已经消失在网络中了。

**为什么存在TIME_WAIT状态**：

主动发起关闭连接的一方，才会有TIME-WAIT状态。它指的是，先断开连接并且已经确认的一方在接收到另一方发送的FIN报文后所进入的状态。TIME_WAIT的存在尽可能保证了其发出的ACK报文能被收到，即保证连接正确关闭。

**为什么TIME_WAIT等待时间为2*MSL**：

2MSL时长其实是相当于至少允许报文丢失一次。因为若ACK在一个MSL内丢失，这样被动方重发的FIN报文会在第2个MSL内到达，TIME_WAIT状态的连接可以应对。

### 可靠传输

**校验和**：

- 发送的数据包的二进制相加然后取反
- 如果收到段的检验和有差错，那么TCP将丢弃这个报文段和不确认收到此报文段
- 检测数据在传输过程中的任何变化

**确认应答+序列号**：

- 接收方每接收到一个包就会向发送方发送确认信息
  - 但这个确认是累积确认，即：会向发送方不断发送连续序号的最后一个（如上图所示，发送1001）
- 接收方之后会将排序好的包组合，并交给应用层

**超时重传**：

- 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。
- 如果不能及时收到一个确认，将重发这个报文段。

**等待时长**：

- 等待时间为最大超时时间，是动态计算的

### 滑动窗口——流量控制

**提出原因**：

- 超时重传机制要求TCP必须等待上一个包确认之后，才能传输新的包，这导致TCP传输效率会很低。
- 滑动窗口使得TCP连接的双方都有固定大小的缓存空间，避免了发送太快来不及接收或者发送太慢效率低下的问题。

**收发流程**：

- 通过下一次的确认包可以判断接收端是否已经接收到了数据，如果已经接收了窗口就向前滑动

**窗口大小**：

- 窗口的大小就是在无需等待确认包的情况下，发送端还能发送的最大数据量。

### 拥塞控制

**拥塞窗口cwnd**：

- 注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口

**主要算法**：

- 慢开始、拥塞避免、快重传、快恢复

### 其他

## Socket

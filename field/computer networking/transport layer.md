# 传输层

- [传输层](#传输层)
  - [UDP](#udp)
  - [TCP](#tcp)
    - [TCP首部](#tcp首部)
    - [三次握手](#三次握手)
    - [四次挥手](#四次挥手)
    - [可靠传输](#可靠传输)
    - [滑动窗口——流量控制](#滑动窗口流量控制)
    - [拥塞控制](#拥塞控制)

## UDP

用户数据报协议UDP（User Datagram Protocol）是一种无连接的，尽最大可能交付、面向报文的传输层通信协议。它的特点包括：

- 无连接：无需维护连接状态。
- 尽最大可能交付：没有滑动窗口等机制确保可靠连接。
- 面向报文：对于应用程序传下来的报文不合并也不拆分，只是添加UDP包头。
- 多种连接方式：支持一对一、一对多、多对一和多对多的交互通信。

## TCP

传输控制协议TCP（Transmission Control Protocol）是一种面向连接的、可靠的、提供拥塞控制和流量控制的传输层通信协议。它的特点包括：

- 面向连接（字节流）：把应用层传下来的报文看成字节流，根据网络情况把字节流组织成大小不等的数据块。
- 提供可靠交付：依靠确认应答以及超时重传机制保证可靠传输。
- 有流量控制和拥塞控制：通过滑动窗口和拥塞窗口实时调整发送速率，TCP能很好适应网络拥塞情况，保证可靠高效传输。
- 仅支持支持一对一连接，无法实现广播和多播通信。
- 双工通信，即客户端和服务端都可以同时充当发送者和接收者的角色。

### TCP首部

![TCP首部](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/55dc4e84-573d-4c13-a765-52ed1dd251f9.png)

**标志位 Flag**：

TCP首部中的标志位（1 bit）用于标识TCP报文段的不同属性和状态。FIN、ACK和SYN是TCP包头中的三个重要的符号位。

- SYN（Synchronize）：SYN标志位用于建立一个TCP连接。在三次握手过程中，主动发起连接的一方会将SYN标志位置为1，表示请求建立连接。接收方收到SYN标志位后，会发送一个SYN+ACK报文作为响应，表示同意建立连接。
- FIN（Finish）：FIN标志位用于结束一个TCP连接。当发送方希望关闭连接时，会将FIN标志位置为1，通知接收方不再发送数据。接收方收到FIN标志位后，会发送一个ACK确认消息，并准备关闭连接。
- ACK（Acknowledgement）：ACK标志位用于确认收到的数据。在TCP协议中，除了用于传输数据的报文段外，还有专门用于确认的ACK报文段。ACK标志位置为1表示该报文段是一个确认报文段，用于确认接收到的数据。

指的注意的是，SYN和FIN才是相对的两个标志位，而非SYN和ACK，因为SYN用于开启TCP连接，而FIN用于关闭TCP连接。至于ACK，它在连接建立后将一直保持为1。

此外，在TCP中，SYN标志位置为1的报文，即SYN报文，不能携带数据，同时还需要消耗一个序号。类似的还有FIN报文，它即使不携带数据也需要消耗一个序号。而与之相反的则是ACK报文，尽管它也允许携带数据，但当它不携带数据时则不消耗序号。

**序号 Sequence Number**：

在TCP报文中只能够提供一个32位的区域用于存储报文序号。当报文序号超过这个范围时，序号字段将循环回零重新计数。换句话说，TCP报文中的序号只是一个相对序号。

在实际通信中，发送者会随机初始化一个32位的起始报文序号（Initial Sequence Number，ISN），并告知接收者。此时，接收者就可以通过将报文中的相对序号（Sequence Number，seqno）与起始序号相加的方式获取实际的绝对序号（Absolute Sequence Number）。这三者的关系如下：

![seqno](https://zhytou.github.io/post/2023-8-4/seqno.png)

**确认号 Acknowledgement Number**：

TCP是一种双工通信协议，这意味着其客户端和服务端都既是发送者也是接收者。这也是为什么它的首部中同时存在序号和确认号两个值。前者在其作为发送方时标识数据包的序列号，而后者则在其作为接收方时表示望接收的下一个字节的序列号。换句话说，确认号其实就是滑动窗口中第一个缺失值序号。

### 三次握手

![三次握手](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e92d0ebc-7d46-413b-aec1-34a39602f787.png)

如上图所示，客户端A主动向服务器端B建立TCP连接的流程如下：

- 首先B处于LISTEN（监听）状态，等待客户的连接请求。
- A向B发送连接请求报文（SYN=1），同时将随机初始化一个序号x。
- B收到连接请求报文，如果同意建立连接，则向A发送连接连接确认报文（SYN=1, ACK=1）。其中，确认号为x+1，而序号则为其随机初始化的一个值y。
- A收到B的连接确认报文后，还要向B发出确认，确认号为y+1，序号为x+1。
- B收到A的确认后，连接建立。

**三次握手的原因**  ：

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

### 四次挥手

![四次握手](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg)

如上图所示，客户端A和服务器端B断开TCP连接的流程如下：

- A发送连接释放报文（FIN=1），B收到之后发出确认。此时，TCP属于半关闭状态，B能向A发送数据但是A不能向B发送数据。
- 当B不再需要连接时，发送连接释放报文（FIN=1）。
- A收到后发出确认，进入TIME-WAIT状态，等待2*MSL（最大报文存活时间）后释放连接。
- B收到A的确认后释放连接。

**四次挥手的原因**  ：

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

### 可靠传输

**校验和**：

- 发送的数据包的二进制相加然后取反
- 如果收到段的检验和有差错，那么TCP将丢弃这个报文段和不确认收到此报文段
- 检测数据在传输过程中的任何变化

**确认应答+序列号**：

- 接收方每接收到一个包就会向发送方发送确认信息
  - 但这个确认是累积确认，即：会向发送方不断发送连续序号的最后一个（如上图所示，发送1001）
- 接收方之后会将排序好的包组合，并交给应用层

**超时重传**：

- 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。
- 如果不能及时收到一个确认，将重发这个报文段。

**等待时长**：

- 等待时间为最大超时时间，是动态计算的

### 滑动窗口——流量控制

**提出原因**：

- 超时重传机制要求TCP必须等待上一个包确认之后，才能传输新的包，这导致TCP传输效率会很低。
- 滑动窗口使得TCP连接的双方都有固定大小的缓存空间，避免了发送太快来不及接收或者发送太慢效率低下的问题。

**收发流程**：

- 通过下一次的确认包可以判断接收端是否已经接收到了数据，如果已经接收了窗口就向前滑动

**窗口大小**：

- 窗口的大小就是在无需等待确认包的情况下，发送端还能发送的最大数据量。

### 拥塞控制

**拥塞窗口cwnd**：

- 注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口

**主要算法**：

- 慢开始、拥塞避免、快重传、快恢复

# 查漏补缺

1、C++ private虚函数有多态吗？引用变量有多态吗？

一般来说，C++开发中都是使用一个父类指针指向一个子类对象来实现多态，但实际上使用引用也能实现多态，即同一个函数父子两个类的对象引用效果不同。对于第一个问题，尽管一个non-virtual函数被定义为private时，它只能被该类的成员函数所访问。但当它是virtual时，它就可以被子类重写的。这是因为编译器不检查虚函数的各类属性。被virtual修饰的成员函数，不论它们是private、protect或是public的，都会被统一的放置到虚函数表中。对父类进行派生时，子类会继承到拥有相同偏移地址的虚函数表（相同偏移地址指，各虚函数相对于VPTR指针的偏移），则子类就会被允许对这些虚函数进行重载。且重载时可以给重载函数定义新的属性，例如public，其只标志着该重载函数在该子类中的访问属性为public，和父类的private属性没有任何关系！

2、STL里面有哪些迭代器？

![STL 迭代器继承关系](https://img-blog.csdnimg.cn/20200804102957172.png)

STL中各种迭代器的继承关系如上图所示。其中，最主要的就是前向迭代器(forward iterator)和双向迭代器(bidirectional iterator)。前者主要实现了比较运算符(==、!=)，递增运算符(++)、解引用(*)和箭头运算符(->)，而后者则是在前者的基础上实现了递减运算符(--)的功能。

3、讲一讲TCP沾包。

4、日志系统中双缓冲法的优势是什么？为什么不直接申请一块大内存？

5、各种关键字和运算符的作用，具体包括：

- extern C
- const
- const_cast
- dynamic_cast vs static_cast
- typename：最主要的作用是模板编程时用于定义萃取出类型名称，比如，使用T中类型Iterator定义一个变量itr代码如下`typename T::iterator * iter;`。
- sizeof：编译时运算符，能够计算任意对象的长度，因此可以用作c语言数组的长度。
- inline：要谨慎使用，如果函数体内的代码过长，使用内联将导致可执行代码膨胀过大。

6、菱形继承的二义性是什么？如何解决？

为两个父类会对公共基类的数据和方法产生一份拷贝，因此对于子类来说读写一个公共基类的数据或调用一个方法时，不知道是哪一个父类的数据和方法，也会导致编译错误。可以采用虚继承的方法解决这个问题(父类继承公共基类时用virtual修饰)，这样就只会创造一份公共基类的实例，不会造成二义性。

7、在(基类的)构造函数和析构函数中调用虚函数会怎么样？

从语法上讲，调用没有问题，但是从效果上看，往往不能达到需要的目的（不能实现多态）；因为调用构造函数的时候，是先进行父类成分的构造，再进行子类的构造。在父类构造期间，子类的特有成分还没有被初始化，此时下降到调用子类的虚函数，使用这些尚未初始化的数据一定会出错；同理，调用析构函数的时候，先对子类的成分进行析构，当进入父类的析构函数的时候，子类的特有成分已经销毁，此时是无法再调用虚函数实现多态的。

8、TCP中time_wait是什么？

9、讲一讲你知道的排序算法，比如：桶排序、快排、堆排序、希尔排序等等。

10、构造函数可以是虚函数吗？析构函数呢？

构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用。那使用虚函数也没有实际意义。而且，在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有构造好, 多态是被disable的。至于析构函数则是可以的，特别是基类的析构函数一定要声明为虚函数。因为常常出现父类指针指向子类对象，所以当该对象析构时必须使用多态，否则就无法调用正确的析构函数。

11、空类sizeof为1，为什么？当在这个类中加入一个虚函数时，它的sizeof返回值变成多少？讲一讲内存对齐。

先了解一个概念：类的实例化，所谓类的实例化就是在内存中分配一块地址，每个实例在内存中都有独一无二的地址。同样空类也会被实例化（别拿豆包不当干粮，空类也是类啊），所以编译器会给空类隐含的添加一个字节，这样空类实例化之后就有了独一无二的地址了。所以空类的sizeof为1。至于在空类中加入虚函数，那么它的大小则变为8。因为它对象中会包含一个虚指针，指向该类的虚表。

内存对齐是编译器为了方便快速访问数据而调整各个数据位置的操作。一般来说，当较大的数据类型放在前面时，较小的数据类型会被填充至较大类型的整数倍。这个过程中可能会产生一些填充字节。此外，如果类有虚函数，它会有一个指向虚函数表（vtable）的指针。该指针同样会影响成员的对齐，它在32位机器上占4字节，在64位机器上则有8字节。至于类的static变量则不需要考虑在内，因为它是属于类共享的。

最后，指的一提的是，使用sizeof计算类或者该类对象的结果总是一致的。换句话说，static成员变量不会算到sizeof值中。因此，下面这段代码输出两个1。

``` c++
struct A {
    static int i;
};

int main() {
    A a;
    // 1
    std::cout << sizeof(A) << std::endl;
    // 1
    std::cout << sizeof(a) << std::endl;
}
```

12、ping是基于什么协议的？它的执行流程是什么？它有端口号吗？比如http的80。它可以测试指定端口的地址是否连通吗？

ping是基于网际报文协议(Internet Control Message Protocol, ICMP)，因此它没有端口号。因为，端口号是TCP/UDP协议用来标识不同的应用程序或服务的，比如，http对应80、ftp对应21和telnet对应23等。至于测试特定端口的连通性，则一般使用telnet命令而非ping命令。

13、讲一讲mmap。

14、DNS解析过程。

15、讲一讲Linux的基本命令。

- netstat、top、grep、sed、awk应用场景

16、海量数据解决方案。

参考[文章](https://www.cnblogs.com/GarrettWale/p/14478347.html)。

17、介绍一下C10K问题和C100K问题。

18、讲一讲QT信号与槽实现机制。

19、如何实现一个CDN系统。

20、Linux内存空间，以及动态链接库放在哪里

进程内存的分配与回收

创建进程fork()、程序载入execve()、映射文件mmap()、动态内存分配malloc()/brk()等进程相关操作都需要分配内存给进程。不过这时进程申请和获得的还不是实际内存，而是虚拟内存，准确的说是“内存区域”。进程对内存区域的分配最终都会归结到do_mmap（）函数上来（brk调用被单独以系统调用实现，不用do_mmap()），内核使用do_mmap()函数创建一个新的线性地址区间。但是说该函数创建了一个新VMA并不非常准确，因为如果创建的地址区间和一个已经存在的地址区间相邻，并且它们具有相同的访问权限的话，那么两个区间将合并为一个。如果不能合并，那么就确实需要创建一个新的VMA了。但无论哪种情况， do_mmap()函数都会将一个地址区间加入到进程的地址空间中－－无论是扩展已存在的内存区域还是创建一个新的区域。同样，释放一个内存区域应使用函数do_ummap()，它会销毁对应的内存区域。

21、memcpy和strcpy的区别是什么？如何实现一个memcpy？

memcpy和strcpy都是C/C++语言中用于字符串或内存块复制的函数。只不过，strcpy参数只包括源地址和目标地址。它会复制从源地址开始直到遇到空字符 \0为止的所有字符。而memcpy需要指定复制的字节数来控制复制的范围。因此，strcpy相比memcpy更容易出错。因为如果源地址的字符串没有以空字符结尾，或者目标地址的内存空间不足以容纳复制的内容，会导致缓冲区溢出和未定义行为的问题。

22、智能指针的循环引用是什么？如何解决这个问题。

23、讲一下KMP算法，它的平均复杂度是多少？

24、讲一下Traits。

25、实现一些线程安全的单例模式。

26、公有继承、保护继承和私有继承的区别。为什么需要私有继承。

27、讲一讲A*算法。

28、什么时候使用多线程？什么时候使用多进程？

29、为什么编译器要分成前端和后端，而不是直接将源代码编译成机器码？

编译器通常分为前端和后端的主要原因是为了提高编译的灵活性、可移植性和效率。以下是一些原因：

- 可移植性：将编译过程分为前端和后端可以使得编译器更容易适应不同的目标平台。前端负责将源代码转换为中间表示形式，这种中间表示形式（如Java字节码或C++汇编）是与特定平台无关的。后端负责将中间表示形式转换为特定平台的机器码。这种分层结构可以让编译器更容易适配新的目标平台，只需要实现新的后端即可。
- 优化：中间表示形式可以提供更多的优化机会。前端可以对源代码进行一些基本的优化，如常量折叠、表达式简化等。而后端可以根据具体的目标平台进行更加深入的优化，如寄存器分配、指令调度等。通过将优化过程分为多个阶段，可以更好地控制和调整优化策略，以提高生成的机器码的效率。
- 可读性和调试：中间表示形式通常比机器码更容易理解和调试。中间表示形式更接近源代码的结构，可以提供更好的可读性和可调试性。这对于开发者来说是非常有价值的，可以更好地理解编译器的输出、进行代码分析和调试。
- 跨平台开发：中间表示形式可以作为跨平台开发的中间层。例如，Java字节码可以在不同的Java虚拟机上运行，而不需要重新编译。这种跨平台特性使得开发者可以编写一次代码，然后在不同的平台上执行。类似地，C++的汇编可以在不同的编译器和操作系统上进行编译和执行。

30、什么是哈夫曼树，它和哈夫曼编码的关系是什么？

31、为什么MySQL的varchar类型最大长度为65335个字节？

MySQL的VARCHAR字段最长为65335个字符的原因是因为它使用了两个字节来存储字段的长度信息。在MySQL中，VARCHAR字段使用变长存储方式，即根据实际存储的数据长度来分配相应的存储空间，这样可以节省存储空间。

32、设计一个汽车摇号系统，每个月放出n个指标，参号人数不固定，要求一个人6年后摇中的概率是当前的2倍。

33、操作系统的文件管理中，一级目录、二级目录和树状目录是什么？

34、常见的协议端口是什么？

35、介绍一下加密手段、TLS/SSL等概念？

36、已知一棵有 2011个结点的树，其叶结点个数为116，该树对应的二叉树中无右孩子的结点个数是？

37、讲一下TCP的拥塞控制？

38、如果一个TCP连接的发送端初始cwnd为1、ssthresh为32，而接收端窗口长度为16，且接收端只确认不处理（即在发送ACK报文后，将收到的包放在接收窗口中不处理），那么4个RTT之后发送端的窗口大小为多少？

39、什么是完美转发，底层是怎么实现的？

完美转发（Perfect Forwarding）是指在函数模板中将参数以原样转发给其他函数，保持参数的值类别（lvalue或rvalue）和常量性（const或非const）不变。完美转发可以用于实现泛型函数和转发函数参数。

在C++中，通过使用两个特殊的引用限定符&&来实现完美转发。这两个引用限定符分别表示右值引用（rvalue reference）和通用引用（universal reference）。

40、​awk 命令怎么使用的，怎么用分隔符，怎么统计行数/列数？

41、​怎么查看进程信息，怎么设置进程优雅退出

使用ps命令可以查看当前运行的进程信息。一种优雅退出的方式是发送信号给进程。常用的信号是SIGINT（中断信号，通常由Ctrl+C发送）和SIGTERM（终止信号）。可以使用kill命令发送信号给进程，例如kill -SIGTERM PID。

42、如何生成全局唯一id来标识用户？

43、OOP的三大特性是什么？C++分别怎么实现他们的？

封装、多态和继承。

44、如果类中仅一个string引用变量，那么它的大小为多少？

```c++
struct A
{
    string& a; 

    A(string& _a):a(_a){}
};
```

该类大小为指针大小。

45、多继承有什么缺点，继承和组合的区别。

多继承是指一个类同时继承自多个父类，而继承则是一个类派生出另一个类。多继承有以下几个缺点：

- 继承的复杂性：多继承会增加类的复杂性，使得代码难以理解和维护。当一个类继承自多个父类时，可能会出现多个父类中有相同成员的情况，导致命名冲突和二义性。
- 耦合度增加：多继承会增加类与父类之间的耦合度，使得类之间的关系更加紧密，降低了代码的灵活性和可重用性。
- Diamond继承问题：当一个类通过多条路径继承自同一个基类时，会导致Diamond继承问题，即同一个基类在派生类中存在多份拷贝，可能会引起数据冗余和内存浪费。

继承和组合的区别主要在于代码复用和类之间的关系：

- 继承：继承是一种"is-a"关系，表示一个类是另一个类的一种特殊形式。通过继承，子类可以继承父类的属性和方法，并且可以通过重写和扩展来实现多态和代码复用。
- 组合：组合是一种"has-a"关系，表示一个类包含另一个类作为成员变量。通过组合，一个类可以使用其他类的功能，而不是继承它的实现。组合可以降低类之间的耦合度，提高代码的灵活性和可维护性。

46、C++ lambda表达式捕获参数可以有哪几种不同情况

捕获列表，是一个lambda所在函数中定义的局部变量的列表。lambda函数体中可以使用这些局部变量。捕获可以分为按值捕获和按引用捕获。非局部变量，如静态变量、全局变量等可以不经捕获，直接使用。

如果捕获列表中，有按值捕获的局部变量，则闭包类中就会有相应的未命名成员变量副本，这些成员变量在定义lambda表达式时就由那些相应的局部变量进行初始化。如果按值捕获的变量是个函数引用，则相应的成员变量是引用指向函数的左值引用；如果是个对象引用，则相应的成员变量是该引用指向的对象。如果是按引用捕获，标准中未指明是否会在闭包类中引入相应的成员变量。

```c++
int a = 1;
// 按值捕获
auto f1 = [a]() {

};
// 引用捕获
auto f2 = [&a]() {

};
// 隐式捕获，使用&指定引用捕获全部变量；使用=指定值捕获全部变量
auto f3 = [=]() {

};
```

47、C++中的final的作用。

- 修饰类，让类无法被继承。
- 修饰类的虚函数，让虚函数在子类中不能被重写。

注意，final只能修饰类与虚函数，无法修饰普通成员函数。

48、死锁和活锁

死锁(Deadlock)是多个竞争资源的进程因为顺序问题而陷入等待的状态，形成循环依赖。它的产生条件如下：

- 互斥：一个资源每次只能被一个进程使用
- 请求与保持：一个进程请求资阻塞时，不释放已获得的资源
- 不剥夺：进程已获得的资源不能强行剥夺
- 循环等待：若干进程之间形成头尾相接的循环等待资源关系

活锁（Livelock）是另一种多个进程因资源竞争导致的等待。与死锁不同的是，死锁是进程都在等待对方先释放资源；而活锁则是进程彼此释放资源又同时占用对方释放的资源。当此情况持续发生时，尽管资源的状态不断改变，但每个进程都无法取得所需资源，使得事情没有任何进展。

49、一个类，设计一个成员函数，返回一个shared_ptr的智能指针，指针指向自己。

enable_shared_from_this

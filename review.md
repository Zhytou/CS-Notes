# 查漏补缺

1、C++ private虚函数有多态吗？引用变量有多态吗？

一般来说，C++开发中都是使用一个父类指针指向一个子类对象来实现多态，但实际上使用引用也能实现多态，即同一个函数父子两个类的对象引用效果不同。对于第一个问题，尽管一个non-virtual函数被定义为private时，它只能被该类的成员函数所访问。但当它是virtual时，它就可以被子类重写的。这是因为编译器不检查虚函数的各类属性。被virtual修饰的成员函数，不论它们是private、protect或是public的，都会被统一的放置到虚函数表中。对父类进行派生时，子类会继承到拥有相同偏移地址的虚函数表（相同偏移地址指，各虚函数相对于VPTR指针的偏移），则子类就会被允许对这些虚函数进行重载。且重载时可以给重载函数定义新的属性，例如public，其只标志着该重载函数在该子类中的访问属性为public，和父类的private属性没有任何关系！

2、STL里面有哪些迭代器？

![STL 迭代器继承关系](https://img-blog.csdnimg.cn/20200804102957172.png)

STL中各种迭代器的继承关系如上图所示。其中，最主要的就是前向迭代器(forward iterator)和双向迭代器(bidirectional iterator)。前者主要实现了比较运算符(==、!=)，递增运算符(++)、解引用(*)和箭头运算符(->)，而后者则是在前者的基础上实现了递减运算符(--)的功能。

3、讲一讲TCP沾包。

4、日志系统中双缓冲法的优势是什么？为什么不直接申请一块大内存？

5、各种关键字和运算符的作用，具体包括：

- extern C
- const
- const_cast
- dynamic_cast vs static_cast
- typename：最主要的作用是模板编程时用于定义萃取出类型名称，比如，使用T中类型Iterator定义一个变量itr代码如下`typename T::iterator * iter;`。
- sizeof：编译时运算符，能够计算任意对象的长度，因此可以用作c语言数组的长度。
- inline：要谨慎使用，如果函数体内的代码过长，使用内联将导致可执行代码膨胀过大。

6、菱形继承的二义性是什么？如何解决？

为两个父类会对公共基类的数据和方法产生一份拷贝，因此对于子类来说读写一个公共基类的数据或调用一个方法时，不知道是哪一个父类的数据和方法，也会导致编译错误。可以采用虚继承的方法解决这个问题(父类继承公共基类时用virtual修饰)，这样就只会创造一份公共基类的实例，不会造成二义性。

7、在(基类的)构造函数和析构函数中调用虚函数会怎么样？

从语法上讲，调用没有问题，但是从效果上看，往往不能达到需要的目的（不能实现多态）；因为调用构造函数的时候，是先进行父类成分的构造，再进行子类的构造。在父类构造期间，子类的特有成分还没有被初始化，此时下降到调用子类的虚函数，使用这些尚未初始化的数据一定会出错；同理，调用析构函数的时候，先对子类的成分进行析构，当进入父类的析构函数的时候，子类的特有成分已经销毁，此时是无法再调用虚函数实现多态的。

8、TCP中time_wait是什么？

9、讲一讲你知道的排序算法，比如：桶排序、快排、堆排序、希尔排序等等。

10、构造函数可以是虚函数吗？析构函数呢？

构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用。那使用虚函数也没有实际意义。而且，在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有构造好, 多态是被disable的。至于析构函数则是可以的，特别是基类的析构函数一定要声明为虚函数。因为常常出现父类指针指向子类对象，所以当该对象析构时必须使用多态，否则就无法调用正确的析构函数。

11、空类sizeof为1，为什么？当在这个类中加入一个虚函数时，它的sizeof返回值变成多少？讲一讲内存对齐。

先了解一个概念：类的实例化，所谓类的实例化就是在内存中分配一块地址，每个实例在内存中都有独一无二的地址。同样空类也会被实例化（别拿豆包不当干粮，空类也是类啊），所以编译器会给空类隐含的添加一个字节，这样空类实例化之后就有了独一无二的地址了。所以空类的sizeof为1。至于在空类中加入虚函数，那么它的大小则变为8。因为它对象中会包含一个虚指针，指向该类的虚表。

内存对齐是编译器为了方便快速访问数据而调整各个数据位置的操作。一般来说，当较大的数据类型放在前面时，较小的数据类型会被填充至较大类型的整数倍。这个过程中可能会产生一些填充字节。此外，如果类有虚函数，它会有一个指向虚函数表（vtable）的指针。该指针同样会影响成员的对齐，它在32位机器上占4字节，在64位机器上则有8字节。至于类的static变量则不需要考虑在内，因为它是属于类共享的。

最后，指的一提的是，使用sizeof计算类或者该类对象的结果总是一致的。换句话说，static成员变量不会算到sizeof值中。因此，下面这段代码输出两个1。

``` c++
struct A {
    static int i;
};

int main() {
    A a;
    // 1
    std::cout << sizeof(A) << std::endl;
    // 1
    std::cout << sizeof(a) << std::endl;
}
```

12、ping是基于什么协议的？它的执行流程是什么？它有端口号吗？比如http的80。它可以测试指定端口的地址是否连通吗？

ping是基于网际报文协议(Internet Control Message Protocol, ICMP)，因此它没有端口号。因为，端口号是TCP/UDP协议用来标识不同的应用程序或服务的，比如，http对应80、ftp对应21和telnet对应23等。至于测试特定端口的连通性，则一般使用telnet命令而非ping命令。

13、讲一讲mmap。

14、DNS解析过程。

15、讲一讲Linux的基本命令。

- netstat、top、grep、sed、awk应用场景

16、海量数据解决方案。

参考[文章](https://www.cnblogs.com/GarrettWale/p/14478347.html)。

17、介绍一下C10K问题和C100K问题。

18、讲一讲QT信号与槽实现机制。

19、如何实现一个CDN系统。

20、Linux内存空间，以及动态链接库放在哪里

进程内存的分配与回收

创建进程fork()、程序载入execve()、映射文件mmap()、动态内存分配malloc()/brk()等进程相关操作都需要分配内存给进程。不过这时进程申请和获得的还不是实际内存，而是虚拟内存，准确的说是“内存区域”。进程对内存区域的分配最终都会归结到do_mmap（）函数上来（brk调用被单独以系统调用实现，不用do_mmap()），内核使用do_mmap()函数创建一个新的线性地址区间。但是说该函数创建了一个新VMA并不非常准确，因为如果创建的地址区间和一个已经存在的地址区间相邻，并且它们具有相同的访问权限的话，那么两个区间将合并为一个。如果不能合并，那么就确实需要创建一个新的VMA了。但无论哪种情况， do_mmap()函数都会将一个地址区间加入到进程的地址空间中－－无论是扩展已存在的内存区域还是创建一个新的区域。同样，释放一个内存区域应使用函数do_ummap()，它会销毁对应的内存区域。

21、memcpy和strcpy的区别是什么？如何实现一个memcpy？

22、智能指针的循环引用是什么？如何解决这个问题。

23、讲一下KMP算法，它的平均复杂度是多少？

24、讲一下Traits。

25、实现一些线程安全的单例模式。

26、公有继承、保护继承和私有继承的区别。为什么需要私有继承。

27、讲一讲A*算法。

28、什么时候使用多线程？什么时候使用多进程？

29、为什么编译器要分成前端和后端，而不是直接将源代码编译成机器码？

编译器通常分为前端和后端的主要原因是为了提高编译的灵活性、可移植性和效率。以下是一些原因：

- 可移植性：将编译过程分为前端和后端可以使得编译器更容易适应不同的目标平台。前端负责将源代码转换为中间表示形式，这种中间表示形式（如Java字节码或C++汇编）是与特定平台无关的。后端负责将中间表示形式转换为特定平台的机器码。这种分层结构可以让编译器更容易适配新的目标平台，只需要实现新的后端即可。
- 优化：中间表示形式可以提供更多的优化机会。前端可以对源代码进行一些基本的优化，如常量折叠、表达式简化等。而后端可以根据具体的目标平台进行更加深入的优化，如寄存器分配、指令调度等。通过将优化过程分为多个阶段，可以更好地控制和调整优化策略，以提高生成的机器码的效率。
- 可读性和调试：中间表示形式通常比机器码更容易理解和调试。中间表示形式更接近源代码的结构，可以提供更好的可读性和可调试性。这对于开发者来说是非常有价值的，可以更好地理解编译器的输出、进行代码分析和调试。
- 跨平台开发：中间表示形式可以作为跨平台开发的中间层。例如，Java字节码可以在不同的Java虚拟机上运行，而不需要重新编译。这种跨平台特性使得开发者可以编写一次代码，然后在不同的平台上执行。类似地，C++的汇编可以在不同的编译器和操作系统上进行编译和执行。

30、什么是哈夫曼树，它和哈夫曼编码的关系是什么？

31、为什么MySQL的varchar类型最大长度为65335个字节？

MySQL的VARCHAR字段最长为65335个字符的原因是因为它使用了两个字节来存储字段的长度信息。在MySQL中，VARCHAR字段使用变长存储方式，即根据实际存储的数据长度来分配相应的存储空间，这样可以节省存储空间。

32、设计一个汽车摇号系统，每个月放出n个指标，参号人数不固定，要求一个人6年后摇中的概率是当前的2倍。

33、操作系统的文件管理中，一级目录、二级目录和树状目录是什么？

34、常见的协议端口是什么？

35、介绍一下加密手段、TLS/SSL等概念？

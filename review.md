# 查漏补缺

1、C++ private虚函数有多态吗？引用变量有多态吗？

一般来说，C++开发中都是使用一个父类指针指向一个子类对象来实现多态，但实际上使用引用也能实现多态，即同一个函数父子两个类的对象引用效果不同。对于第一个问题，尽管一个non-virtual函数被定义为private时，它只能被该类的成员函数所访问。但当它是virtual时，它就可以被子类重写的。这是因为编译器不检查虚函数的各类属性。被virtual修饰的成员函数，不论它们是private、protect或是public的，都会被统一的放置到虚函数表中。对父类进行派生时，子类会继承到拥有相同偏移地址的虚函数表（相同偏移地址指，各虚函数相对于VPTR指针的偏移），则子类就会被允许对这些虚函数进行重载。且重载时可以给重载函数定义新的属性，例如public，其只标志着该重载函数在该子类中的访问属性为public，和父类的private属性没有任何关系！

2、STL里面有哪些迭代器？

![STL 迭代器继承关系](https://img-blog.csdnimg.cn/20200804102957172.png)

STL中各种迭代器的继承关系如上图所示。其中，最主要的就是前向迭代器(forward iterator)和双向迭代器(bidirectional iterator)。前者主要实现了比较运算符(==、!=)，递增运算符(++)、解引用(*)和箭头运算符(->)，而后者则是在前者的基础上实现了递减运算符(--)的功能。

3、讲一讲TCP沾包。

4、日志系统中双缓冲法的优势是什么？为什么不直接申请一块大内存？

5、各种关键字和运算符的作用，具体包括：

- extern C
- const
- const_cast
- dynamic_cast vs static_cast
- typename：最主要的作用是模板编程时用于定义萃取出类型名称，比如，使用T中类型Iterator定义一个变量itr代码如下`typename T::iterator * iter;`。
- sizeof：编译时运算符，能够计算任意对象的长度，因此可以用作c语言数组的长度。
- inline：要谨慎使用，如果函数体内的代码过长，使用内联将导致可执行代码膨胀过大。

6、菱形继承的二义性是什么？如何解决？

为两个父类会对公共基类的数据和方法产生一份拷贝，因此对于子类来说读写一个公共基类的数据或调用一个方法时，不知道是哪一个父类的数据和方法，也会导致编译错误。可以采用虚继承的方法解决这个问题(父类继承公共基类时用virtual修饰)，这样就只会创造一份公共基类的实例，不会造成二义性。

7、在(基类的)构造函数和析构函数中调用虚函数会怎么样？

从语法上讲，调用没有问题，但是从效果上看，往往不能达到需要的目的（不能实现多态）；因为调用构造函数的时候，是先进行父类成分的构造，再进行子类的构造。在父类构造期间，子类的特有成分还没有被初始化，此时下降到调用子类的虚函数，使用这些尚未初始化的数据一定会出错；同理，调用析构函数的时候，先对子类的成分进行析构，当进入父类的析构函数的时候，子类的特有成分已经销毁，此时是无法再调用虚函数实现多态的。

8、TCP中time_wait是什么？

9、讲一讲你知道的排序算法，比如：桶排序、快排、堆排序、希尔排序等等。

10、构造函数可以是虚函数吗？析构函数呢？

构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用。那使用虚函数也没有实际意义。而且，在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有构造好, 多态是被disable的。至于析构函数则是可以的，特别是基类的析构函数一定要声明为虚函数。因为常常出现父类指针指向子类对象，所以当该对象析构时必须使用多态，否则就无法调用正确的析构函数。

11、空类sizeof为1，为什么？当在这个类中加入一个虚函数时，它的sizeof返回值变成多少？讲一讲内存对齐。

先了解一个概念：类的实例化，所谓类的实例化就是在内存中分配一块地址，每个实例在内存中都有独一无二的地址。同样空类也会被实例化（别拿豆包不当干粮，空类也是类啊），所以编译器会给空类隐含的添加一个字节，这样空类实例化之后就有了独一无二的地址了。所以空类的sizeof为1。至于在空类中加入虚函数，那么它的大小则变为8。因为它对象中会包含一个虚指针，指向该类的虚表。

内存对齐是编译器为了方便快速访问数据而调整各个数据位置的操作。一般来说，当较大的数据类型放在前面时，较小的数据类型会被填充至较大类型的整数倍。这个过程中可能会产生一些填充字节。此外，如果类有虚函数，它会有一个指向虚函数表（vtable）的指针。该指针同样会影响成员的对齐，它在32位机器上占4字节，在64位机器上则有8字节。至于类的static变量则不需要考虑在内，因为它是属于类共享的。

最后，指的一提的是，使用sizeof计算类或者该类对象的结果总是一致的。换句话说，static成员变量不会算到sizeof值中。因此，下面这段代码输出两个1。

``` c++
struct A {
    static int i;
};

int main() {
    A a;
    // 1
    std::cout << sizeof(A) << std::endl;
    // 1
    std::cout << sizeof(a) << std::endl;
}
```

12、ping是基于什么协议的？它的执行流程是什么？它有端口号吗？比如http的80。它可以测试指定端口的地址是否连通吗？

ping是基于网际报文协议(Internet Control Message Protocol, ICMP)，因此它没有端口号。因为，端口号是TCP/UDP协议用来标识不同的应用程序或服务的，比如，http对应80、ftp对应21和telnet对应23等。至于测试特定端口的连通性，则一般使用telnet命令而非ping命令。

13、讲一讲mmap。

14、DNS解析过程。

15、讲一讲Linux的基本命令。

- netstat、top、grep、sed、awk应用场景

16、海量数据解决方案。

参考[文章](https://www.cnblogs.com/GarrettWale/p/14478347.html)。

17、介绍一下C10K问题和C100K问题。

18、讲一讲QT信号与槽实现机制。

19、如何实现一个CDN系统。

20、Linux内存空间，以及动态链接库放在哪里

进程内存的分配与回收

创建进程fork()、程序载入execve()、映射文件mmap()、动态内存分配malloc()/brk()等进程相关操作都需要分配内存给进程。不过这时进程申请和获得的还不是实际内存，而是虚拟内存，准确的说是“内存区域”。进程对内存区域的分配最终都会归结到do_mmap（）函数上来（brk调用被单独以系统调用实现，不用do_mmap()），内核使用do_mmap()函数创建一个新的线性地址区间。但是说该函数创建了一个新VMA并不非常准确，因为如果创建的地址区间和一个已经存在的地址区间相邻，并且它们具有相同的访问权限的话，那么两个区间将合并为一个。如果不能合并，那么就确实需要创建一个新的VMA了。但无论哪种情况， do_mmap()函数都会将一个地址区间加入到进程的地址空间中－－无论是扩展已存在的内存区域还是创建一个新的区域。同样，释放一个内存区域应使用函数do_ummap()，它会销毁对应的内存区域。

21、memcpy和strcpy的区别是什么？如何实现一个memcpy？

memcpy和strcpy都是C/C++语言中用于字符串或内存块复制的函数。只不过，strcpy参数只包括源地址和目标地址。它会复制从源地址开始直到遇到空字符 \0为止的所有字符。而memcpy需要指定复制的字节数来控制复制的范围。因此，strcpy相比memcpy更容易出错。因为如果源地址的字符串没有以空字符结尾，或者目标地址的内存空间不足以容纳复制的内容，会导致缓冲区溢出和未定义行为的问题。

22、智能指针的循环引用是什么？如何解决这个问题。

23、讲一下KMP算法，它的平均复杂度是多少？

24、讲一下Traits。

25、实现一些线程安全的单例模式。

26、公有继承、保护继承和私有继承的区别。为什么需要私有继承。

27、讲一讲A*算法。

28、什么时候使用多线程？什么时候使用多进程？

29、为什么编译器要分成前端和后端，而不是直接将源代码编译成机器码？

编译器通常分为前端和后端的主要原因是为了提高编译的灵活性、可移植性和效率。以下是一些原因：

- 可移植性：将编译过程分为前端和后端可以使得编译器更容易适应不同的目标平台。前端负责将源代码转换为中间表示形式，这种中间表示形式（如Java字节码或C++汇编）是与特定平台无关的。后端负责将中间表示形式转换为特定平台的机器码。这种分层结构可以让编译器更容易适配新的目标平台，只需要实现新的后端即可。
- 优化：中间表示形式可以提供更多的优化机会。前端可以对源代码进行一些基本的优化，如常量折叠、表达式简化等。而后端可以根据具体的目标平台进行更加深入的优化，如寄存器分配、指令调度等。通过将优化过程分为多个阶段，可以更好地控制和调整优化策略，以提高生成的机器码的效率。
- 可读性和调试：中间表示形式通常比机器码更容易理解和调试。中间表示形式更接近源代码的结构，可以提供更好的可读性和可调试性。这对于开发者来说是非常有价值的，可以更好地理解编译器的输出、进行代码分析和调试。
- 跨平台开发：中间表示形式可以作为跨平台开发的中间层。例如，Java字节码可以在不同的Java虚拟机上运行，而不需要重新编译。这种跨平台特性使得开发者可以编写一次代码，然后在不同的平台上执行。类似地，C++的汇编可以在不同的编译器和操作系统上进行编译和执行。

30、什么是哈夫曼树，它和哈夫曼编码的关系是什么？

31、为什么MySQL的varchar类型最大长度为65335个字节？

MySQL的VARCHAR字段最长为65335个字符的原因是因为它使用了两个字节来存储字段的长度信息。在MySQL中，VARCHAR字段使用变长存储方式，即根据实际存储的数据长度来分配相应的存储空间，这样可以节省存储空间。

32、设计一个汽车摇号系统，每个月放出n个指标，参号人数不固定，要求一个人6年后摇中的概率是当前的2倍。

33、操作系统的文件管理中，一级目录、二级目录和树状目录是什么？

34、常见的协议端口是什么？

35、介绍一下加密手段、TLS/SSL等概念？

36、已知一棵有 2011个结点的树，其叶结点个数为116，该树对应的二叉树中无右孩子的结点个数是？

37、讲一下TCP的拥塞控制？

38、如果一个TCP连接的发送端初始cwnd为1、ssthresh为32，而接收端窗口长度为16，且接收端只确认不处理（即在发送ACK报文后，将收到的包放在接收窗口中不处理），那么4个RTT之后发送端的窗口大小为多少？

39、什么是完美转发，底层是怎么实现的？

完美转发（Perfect Forwarding）是指在函数模板中将参数以原样转发给其他函数，保持参数的值类别（lvalue或rvalue）和常量性（const或非const）不变。完美转发可以用于实现泛型函数和转发函数参数。

在C++中，通过使用两个特殊的引用限定符&&来实现完美转发。这两个引用限定符分别表示右值引用（rvalue reference）和通用引用（universal reference）。

40、​awk 命令怎么使用的，怎么用分隔符，怎么统计行数/列数？

41、​怎么查看进程信息，怎么设置进程优雅退出

使用ps命令可以查看当前运行的进程信息。一种优雅退出的方式是发送信号给进程。常用的信号是SIGINT（中断信号，通常由Ctrl+C发送）和SIGTERM（终止信号）。可以使用kill命令发送信号给进程，例如kill -SIGTERM PID。

42、如何生成全局唯一id来标识用户？

43、OOP的三大特性是什么？C++分别怎么实现他们的？

封装、多态和继承。

44、如果类中仅一个string引用变量，那么它的大小为多少？

```c++
struct A
{
    string& a; 

    A(string& _a):a(_a){}
};
```

该类大小为指针大小。

45、多继承有什么缺点，继承和组合的区别。

多继承是指一个类同时继承自多个父类，而继承则是一个类派生出另一个类。多继承有以下几个缺点：

- 继承的复杂性：多继承会增加类的复杂性，使得代码难以理解和维护。当一个类继承自多个父类时，可能会出现多个父类中有相同成员的情况，导致命名冲突和二义性。
- 耦合度增加：多继承会增加类与父类之间的耦合度，使得类之间的关系更加紧密，降低了代码的灵活性和可重用性。
- Diamond继承问题：当一个类通过多条路径继承自同一个基类时，会导致Diamond继承问题，即同一个基类在派生类中存在多份拷贝，可能会引起数据冗余和内存浪费。

继承和组合的区别主要在于代码复用和类之间的关系：

- 继承：继承是一种"is-a"关系，表示一个类是另一个类的一种特殊形式。通过继承，子类可以继承父类的属性和方法，并且可以通过重写和扩展来实现多态和代码复用。
- 组合：组合是一种"has-a"关系，表示一个类包含另一个类作为成员变量。通过组合，一个类可以使用其他类的功能，而不是继承它的实现。组合可以降低类之间的耦合度，提高代码的灵活性和可维护性。

46、C++ lambda表达式捕获参数可以有哪几种不同情况

捕获列表，是一个lambda所在函数中定义的局部变量的列表。lambda函数体中可以使用这些局部变量。捕获可以分为按值捕获和按引用捕获。非局部变量，如静态变量、全局变量等可以不经捕获，直接使用。

如果捕获列表中，有按值捕获的局部变量，则闭包类中就会有相应的未命名成员变量副本，这些成员变量在定义lambda表达式时就由那些相应的局部变量进行初始化。如果按值捕获的变量是个函数引用，则相应的成员变量是引用指向函数的左值引用；如果是个对象引用，则相应的成员变量是该引用指向的对象。如果是按引用捕获，标准中未指明是否会在闭包类中引入相应的成员变量。

```c++
int a = 1;
// 按值捕获
auto f1 = [a]() {

};
// 引用捕获
auto f2 = [&a]() {

};
// 隐式捕获，使用&指定引用捕获全部变量；使用=指定值捕获全部变量
auto f3 = [=]() {

};
```

47、C++中的final的作用。

- 修饰类，让类无法被继承。
- 修饰类的虚函数，让虚函数在子类中不能被重写。

注意，final只能修饰类与虚函数，无法修饰普通成员函数。

48、死锁和活锁

死锁(Deadlock)是多个竞争资源的进程因为顺序问题而陷入等待的状态，形成循环依赖。它的产生条件如下：

- 互斥：一个资源每次只能被一个进程使用
- 请求与保持：一个进程请求资阻塞时，不释放已获得的资源
- 不剥夺：进程已获得的资源不能强行剥夺
- 循环等待：若干进程之间形成头尾相接的循环等待资源关系

活锁（Livelock）是另一种多个进程因资源竞争导致的等待。与死锁不同的是，死锁是进程都在等待对方先释放资源；而活锁则是进程彼此释放资源又同时占用对方释放的资源。当此情况持续发生时，尽管资源的状态不断改变，但每个进程都无法取得所需资源，使得事情没有任何进展。

49、一个类，设计一个成员函数，返回一个shared_ptr的智能指针，指针指向自己。

enable_shared_from_this

50、shared_ptr使用和不用make_shared初始化的区别

```c++
shared_ptr<int> p1 = make_shared<int>(10);

int* p = new int(10);
shared_ptr<int> p2(p);
```

51、当模板函数和普通函数重命名时，调用该函数会发生什么？编译会报错吗？

```c++
template<class T>
void func(T t) {
    cout << "template func " <<  t << endl;
}

void func(int t) {
    cout << "normal func " <<  t << endl;
}

int main() {
    func(1);
}
```

上述代码编译会通过，执行后输出normal func 1。

52、atomic的实现原理？

53、C++ memory_order是什么？

54、自旋锁

55、dynamic_cast背后的原理（RTTI）

56、inline函数必须定义在头文件里吗？

是的，特别是如果一个inline会在多个源文件中被用到，那么必须把它定义在头文件中。因为内联的目的就是在编译期让编译器把使用函数的地方直接替换掉，而不是像普通函数一样通过链接器把地址链接上。这种情况，如果定义没有在头文件的话，编译器是无法进行函数替换的。

57、头文件中可以放哪些东西的定义？

一般来说，头文件中变量和函数的声明，而不要放定义进去。否则就会有重复定义的错误出现。但是有几种情况是例外的：

- 内联函数的定义
- 类（class）的定义
- const 和 static 变量

58、QT信号和槽函数的底层原理

Qt信号和槽是一种用于实现对象间通信的机制。在接收对象中定义好槽函数之后，就可以使用connect将二者绑定起来。比如：

```c++
QSlider* sld = new QSlider();
sld->setOrientation(Qt::Horizontal);
connect(sld, &QSlider::valueChanged, this, [this](int x) {
    // ...
});
```

此外，除了使用Qt组件中原生信号之外，还可以自定义信号。比如：

```c++
class XXX : public QObject {
    Q_OBJECT // 必须包含这一行，用于启用元对象系统

public:
    explicit XXX(QObject *parent = nullptr);

signals:
    void xxx(int value); // 声明一个带整型参数的自定义信号
};
```

当需要发出信号时，使用emit关键字加上信号名和参数列表来触发信号。例如：

```c++
emit xxx(42); // 发出自定义信号，并传递整数值42
```

本质上，信号槽是一种事件驱动的机制。通过信号和槽的连接，当信号被触发时，槽函数会被自动调用，从而实现对象间的通信和交互。

具体来说，信号和槽都是特殊的函数。前者用于表示某种事件的发生，当事件发生时，信号会被自动发送出去，通知所有连接到该信号的槽函数。而后者用于处理信号的触发事件，当槽函数被连接到某个信号时，当该信号被触发时，槽函数会自动被调用，从而实现对信号的响应。

至于，信号和槽的连接是通过Qt的元对象系统实现的，每个QObject派生类都有一个元对象，用于存储该类的属性、方法和信号槽信息。通过元对象系统，可以在运行时动态地连接信号和槽，从而实现对象间的通信。 总之，Qt信号和槽是一种事件驱动的机制，通过信号和槽的连接，实现了对象间的通信和交互。

59、Qt的元对象系统是什么？和C++ RTTI有什么关系？

Qt的元对象系统(Qt Meta Object System)提供了以下三样基础设施：

- QObject类，作为每一个需要利用元对象系统的类的基类。也就是说只有继承QObject类才能使用MOS。
- Q_OBJECT宏，定义在每一个类的私有数据段，用来启用元对象功能，比如，动态属性、信号和槽。
- 元对象编译器moc（Meta Object Compiler），如果一个头文件中包含Q_OBJECT宏定义，moc就会将该文件编译成C++源文件。

继承于QObject的自定义对象除了能够获得信号槽带来的通讯机制之外，还获得了以下能力：

- QObject::metaObject()方法，获得与一个类相关联的meta-object。
- QMetaObject::className()方法，在运行期间返回一个对象的类名，不需要本地C++编译器的RTTI（run time type information）支持。
- QObject::inherits()方法，用来判断一个对象的类是不是从一个特定的类继承而来。

换句话说，Qt的元对象系统就是独立于RTTI，用于提供对象的元数据（如信号和槽、属性、动态属性等）和运行时类型信息，所实现的一套C++扩展机制。

60、对malloc到的内存使用delete函数会发生什么？delete和free的本质区别是什么？

delete会调用析构函数，free不会。类似的，new会调用构造函数，而malloc不会。

61、virtual函数可以是inline的吗？

可以是，只要该函数参数不是该类型指针或引用，即避免了运行时多态就可以。

62、不考虑经济因素，为什么计算机的缓存要设计成多层级结构？如果技术上成立的话，为什么不将缓存设计成特别大的一层？

即使技术上成立，这样单层的缓存结构也失去了其利用数据局部性原理来提高访问性能的意义了。因为最频繁访问的数据其实是相对有限的，过大的缓存存在边际效应，且会带来不必要的能耗。

63、UTF-8和UTF-16的区别是什么？其中的8和16的含义是什么？

UTF-8 和 UTF-16 中的数字 8 和 16 指的是每个字符编码所占用的位数，也就是字节数。

在 UTF-8 编码中，每个字符的编码长度可以是 1 到 4 个字节。最常见的情况是，ASCII 字符（0-127）占用一个字节，拉丁文字符和其他常见字符占用两个字节，而少见字符和特殊字符占用三到四个字节。UTF-8 是一种变长编码方式，可以根据字符的 Unicode 码点来确定所需的字节数，因此在存储英文等常见字符时比较节省空间。

而在 UTF-16 编码中，每个字符固定占用 16 位（2 个字节）的空间。UTF-16 是一种固定宽度编码方式，无论字符是英文、中文还是其他语言，都占用两个字节的空间。这使得 UTF-16 在处理非常用字符时会比 UTF-8 更有效率，但在处理英文等常见字符时可能会浪费空间。

因此，UTF-8 和 UTF-16 中的 8 和 16 指的是每个字符编码所占用的位数或字节数，这决定了它们在存储和表示不同字符时的特点和优势。UTF-8 更适合存储英文和常见字符，而 UTF-16 更适合处理包含大量非常用字符的文本。

64、开放定址法、链地址法（拉链法）和再哈希法的适用场景。

开放定址法适合于内存空间有限的情况，因为它不需要额外的空间来存储冲突的键值对。在开放定址法中，当发生冲突时，会尝试在哈希表中的其他位置寻找空槽位来存储冲突的键值对，通常有线性探测、二次探测和双重散列等方式。但它的缺点是容易产生聚集，影响性能，且其删除操作相对复杂。

链地址法适合于存储大量数据和频繁进行插入和删除操作的场景。在链地址法中，每个槽位存储一个链表或其他数据结构，用于存储冲突的键值对。它的优点是容易实现，插入和删除操作效率高；缺点是需要额外的空间来存储链表或其他数据结构，可能会占用更多内存。

再哈希法适用于要求较高的哈希表性能的场景。在再哈希法中，当发生冲突时，会使用另一个哈希函数对冲突的键值对进行再次哈希，以寻找新的槽位。它可以减少冲突，提高哈希表的性能。但缺点是需要设计和实现多个哈希函数，可能增加复杂性。

65、Http和RPC的区别是什么？为什么客户端和服务端相连使用HTTP，而服务端中各个微服务相连使用RPC？

66、gdb和valgrind的使用

# 构造 & 析构

- [构造 \& 析构](#构造--析构)
  - [构造函数](#构造函数)
    - [默认构造函数](#默认构造函数)
    - [委托构造函数](#委托构造函数)
    - [初始化列表](#初始化列表)
    - [拷贝构造函数](#拷贝构造函数)
    - [拷贝赋值运算符](#拷贝赋值运算符)
    - [移动构造函数](#移动构造函数)
    - [阻止特定构造方式](#阻止特定构造方式)
  - [析构函数](#析构函数)
  - [三五法则](#三五法则)

## 构造函数

每个类都分别定义了它的对象被初始化的方式，即：通过一个或几个特殊成员函数来控制其对象初始化的过程，这些函数被成为构造函数（Constructor）。

一般来说，构造函数初始化值顺序应该和其成员声明的顺序保持一致。而且应该尽量避免使用某些成员初始化其他成员。

**执行顺序**：

基类构造函数中的初始化列表->基类构造函数中的函数体->……->最底层派生类的初始化列表->最底层派生类构造函数中的函数体

### 默认构造函数

默认构造函数是指不提供任何额外参数的构造函数。

如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。

**合成的默认构造函数**：

一般来说，如果一个类没有定义构造函数，那么编译器会为这个类创建一个构造函数，即：合成的构造函数。

我们可以使用`=default`来显式的要求编译器生成构造函数。

### 委托构造函数

C++11 新标准扩展了构造函数初始值的功能，使得我们可以定义所谓的委托构造函数，即：在构造函数中调用另一个构造函数。例如：

```c++
class A {
public:
  A(string s, int cnt, double price): name_(s), sold_cnt_(cnt), revenue_(cnt * price) {}
  A() : A("", 0, 0) {}
  A(string s) : A(s, 0, 0) {} 
private:
  string name_;
  int sold_cnt_;
  double revenue_;
}
```

### 初始化列表

构造函数初始化列表以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟一个放在括号中的初始化格式。它允许开发者快捷明了的初始化所有对象成员。

**const、引用和静态成员**：

值得注意的是，构造函数必须初始化`const`和引用成员。而静态成员则是在类外定义并赋值（因为类共享）。

### 拷贝构造函数

**拷贝构造函数**：

如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。

**合成拷贝构造函数**：

如果我们没有定义一个拷贝构造函数，编译器会为我们定义一个。

与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。

### 拷贝赋值运算符

**重载赋值运算符**：

重载运算符本质是函数，其名字由`operator`关键字后续接要定义的运算符号组成。因此，赋值运算符就是一个名为`operator=`的函数。

**合成拷贝赋值运算符**：

与拷贝构造函数一样，如果一个类未定义它自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符。

### 移动构造函数

如果一个构造函数的第一个参数是自身类类型的右值引用，且任何额外参数都有默认值，则则此构造函数是移动构造函数。

除了完成资源移动之外，移动构造函数还必须保证移动后源对象处于销毁状态——它是无害的。特别是，一旦资源移动完成，源对象就必须不再指向被移动资源——这些资源的所有权已经归属到新创建的对象。

### 阻止特定构造方式

**explicit**：

我们可以将构造函数声明为`explicit`来阻止参数的隐式转换而发生的调用。例如：

``` c++
explicit void func(vector<int> a);

//错误，不能使用一个explicit的拷贝构造函数来拷贝一个实参
func(10);
//正确，使用一个int构造一个临时的vector，再调用拷贝构造函数
func(vector<int>(10));
```

**= deleted**：

我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝，即：在函数的参数列表后面加上`=deleted`来指出我们希望将它定义为删除的。

**private**：

此外，我们也可以将拷贝构造函数和拷贝赋值运算符声明为`private`的来阻止拷贝。

## 析构函数

析构函数是一个成员函数，在对象超出范围或通过调用delete显式销毁对象时，会自动调用析构函数。 析构函数具有与类相同的名称，前面是波形符 (~)。

**执行顺序**：

派生类析构函数->……->最顶层基类的析构函数

**虚析构函数**：

总的来说虚析构函数是为了避免内存泄露，而且是当子类中会有指针成员变量时才会使用得到的。也就说虚析构函数使得在删除指向子类对象的基类指针时可以调用子类的析构函数达到释放子类中堆内存的目的，而防止内存泄露的。

## 三五法则

# 继承与多态

- [继承与多态](#继承与多态)
  - [继承](#继承)
    - [继承访问控制符](#继承访问控制符)
    - [final 和 override 说明符](#final-和-override-说明符)
    - [菱形继承](#菱形继承)
  - [多态](#多态)
    - [分类](#分类)
    - [实现](#实现)
    - [静态绑定 vs 动态绑定](#静态绑定-vs-动态绑定)
  - [虚函数 Virtual Function](#虚函数-virtual-function)
    - [纯虚函数](#纯虚函数)
    - [虚表 Virtual Table](#虚表-virtual-table)
  - [参考](#参考)

## 继承

**成员函数与继承**：

在C++语言中，基类必须将它的两种成员函数分开来：一种是基类希望派生类进行覆盖的虚函数；另一种是派生类直接继承而不要改变的函数。

**构造函数与继承**：

尽管派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。派生类必须使用基类的构造函数来初始化它基类的部分。

构造函数的执行顺序：

- 调用基类构造函数。
- 对初始化列表中的成员进行初始化。
- 执行派生类的构造函数体中的内容。

**静态成员与继承**：

如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。

**友元与继承**：

基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。

**模板与继承**：

见[模板与泛型编程总结](/language/c++/basical/template%20and%20generic%20programming.md)

### 继承访问控制符

**继承控制**：

某个类对其继承而来的成员的访问权限受到两个因素影响：一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。

- `public`
- `protected`
- `private`

其中，`class`关键字默认是私有继承；而`struct`关键字默认使用共有继承。

**改变个别成员的可访问性**：

我们可以通过使用`using`声明改变继承的某个名字的访问级别。

### final 和 override 说明符

**override**：

C++11 新标准中我们可以使用`override`关键字来说明派生类中的虚函数。

这么做的好处是使得程序员的意图更加清晰的同时让编译器为我们发现一些错误。

如果我们使用了`override`标记了某个函数，但该函数没有覆盖已经存在的虚函数，此时编译器会报错。因为如果派生类定义了一个普通（或虚）函数与基类中函数的名字相同但形参列表不同，这仍然是合法的。

**final**：

C++11 新标准提供了一种防止继承发生的方法，即在类后跟一个关键字`final`。

### 菱形继承

菱形继承问题是指在多重继承中出现的一种特定情况，其中一个派生类同时从两个不同的基类继承，而这两个基类又都继承自同一个共同的基类。这种情况形成了一个菱形的继承结构，因此被称为菱形继承问题。

菱形继承可能会引发一些问题，主要是：

- 内存重复：由于 Derived 类同时继承了 Base1 和 Base2 中的 Base 部分，因此可能会导致 Base 类的成员在内存中重复存储，造成资源浪费。
- 命名冲突：如果 Base1 和 Base2 中有相同名称的成员或方法，那么在 Derived 类中就会出现命名冲突，需要使用作用域解析运算符来消除歧义。

为了解决菱形继承问题，C++ 引入了虚拟继承，其中通过虚拟继承 Base 类，使得 Derived 类只继承一份 Base 类的成员，从而解决了重复继承和命名冲突的问题。比如：

```c++
class Base {
    // 基类的成员和方法
};

class Derived1 : virtual public Base {
    // 派生类1从基类虚拟继承成员和方法
};

class Derived2 : virtual public Base {
    // 派生类2从基类虚拟继承成员和方法
};

class Derived3 : public Derived1, public Derived2 {
    // 派生类3从派生类1和派生类2继承成员和方法
};
```

## 多态

关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。

而所谓的泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。

### 分类

C++中多态可以分成四类：

- 参数多态：函数模板和类模板
- 包含多态：虚函数
- 重载多态：函数重载、运算符重载
- 强制多态：指将一个变元的类型加以变化，以符合一个函数或操作的要求

### 实现

在C++中，多态的实现和联编这一概念有关。

所谓联编就是把函数名与函数体的程序代码连接(联系)在一起的过程。

- 静态联编就是在编译阶段完成的联编。
- 动态联编是运行阶段完成的联编。

纯粹的面向对象程序设计语言由于其执行机制是消息传递，所以只能采用动态联编。这就给基于C语言的 C++ 带来了麻烦。因为为了保持C语言的高效性，C++仍是编译型的，仍采用静态联编。好在 C++ 的设计者想出了“虚函数” 的机制，解决了这个问题。利用虚函数机制，C++ 可部分地采用动态联编。这就是说，C++ 实际上是采用了静态联编和动态联编相结合的联编方法。

在C++中， 编译时多态性主要是通过函数重载和运算符重载实现的。 运行时多态性主要是通过虚函数来实现的。

### 静态绑定 vs 动态绑定

**静态类型 vs 动态类型**：

表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；

动态类型则是变量或表达式表示的内存中对象的类型，动态类型直到运行时才可知。

**静态绑定 vs 动态绑定**：

当我们使用基类的引用或指针调用基类定义的一个函数时，我们并不知道该函数真正作用的对象是什么类型，因为它可能是一个基类对象也可能是一个派生类的对象。

- 如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本，判断依据是引用或指针绑定的对象的真实类型。
- 而对非虚函数的调用则是在编译时进行绑定。

此外，通过对象进行的函数调用也是在编译时进行绑定，因为对象的类型是确定不变的。

## 虚函数 Virtual Function

某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成`虚函数(virtual function)`。

**形参和返回类型都必须匹配**：

派生类中虚函数的形参和返回类型都必须和基类中匹配。

但该规制存在一个例外，当类的虚函数返回类型是该类本身的指针或引用时，上述规则无效。

**可以在派生类再次声明为virtual**：

派生类中的虚函数可以使用`virtual`关键字指出该函数的性质。

**构造函数不能是虚函数**：

因为虚函数的作用在于通过父类的指针或引用来调用它的时候变成调用子类的成员函数。

而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用，因此也就规定构造函数不能是虚函数。

**析构函数大多数时候是虚函数**：

因为如果虚函数不是虚函数的话，那么在析构一个由父类指针指向的子类对象时，就不会发生动态绑定，也就只能调用父类析构函数，即：无法销毁子类独有的部分元素。

**回避虚函数机制**：

在某些情况下，我们希望对虚函数的调用不进行动态绑定，而是强迫其执行虚函数的某个版本。使用作用域运算符可以实现这一目的。

### 纯虚函数

通过在函数体的位置处书写`=0`可以将一个虚函数声明为纯虚函数。

**抽象基类**：

含有纯虚函数的类是抽象基类。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能直接创建一个抽象基类的对象。

### 虚表 Virtual Table

虚函数指针是在C++中实现多态性的一种机制。一个类中声明了虚函数时，编译器会在该类中生成一个虚函数表，其中存储了该类中所有虚函数的地址。虚函数实现相关的变量在内存中的位置如下图。

![虚表数据](https://img-blog.csdnimg.cn/2021032617400189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1J1bm5lcl9vZl9ua3U=,size_16,color_FFFFFF,t_70)

可见，堆区的对象中有一个虚函数表指针。该指针指向只读数据段(.rodata)中的虚表，这使得同一类的不同对象能够共享一张虚表。而虚表中每个元素，即虚函数指针，则指向代码段(.text)中相应的函数实现。

**虚指针 Virtual Pointer**：

每个对象中都有一个指向该类的虚函数表的指针，称为虚函数指针。

当对象被创建时，编译器会将该对象的虚函数指针指向该类的虚函数表。此外，C++的编译器保证虚函数表的指针总是存在于对象实例中最前面的位置。

**虚表如何帮助实现多态**：

![类继承关系](https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_Drawing4.jpg)

假设上图中两个类有上述继承关系，其虚函数表则会将派生类中`f()`函数放置在原父类`f()`函数的位置，以实现函数覆盖。

![虚表](https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_vtable3.JPG)

因此，当执行下列程序时，由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。

``` c++
Base* b = new Derive();
b->f();
```

**普通成员函数 vs 虚成员函数**：

普通成员函数是存在类的定义中的，但它们不会存储在虚函数表中。

普通成员函数的代码只会在编译时生成一份，并被所有实例共享，不会为每个实例生成一份。当调用一个普通成员函数时，实际上是将该函数的地址作为参数传递给该函数所属的对象，然后通过该对象调用该函数。因此，每个对象都不需要保存一个指向该函数的指针，而是通过该函数的地址和对象调用该函数。

## 参考

**虚函数、虚表、动态绑定**：

- [陈皓-虚函数解析](https://blog.csdn.net/haoel/article/details/1948051)

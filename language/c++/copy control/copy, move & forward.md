# 拷贝控制

- [拷贝控制](#拷贝控制)
  - [拷贝](#拷贝)
  - [移动](#移动)
    - [std::move](#stdmove)
  - [完美转发](#完美转发)
    - [std::forward](#stdforward)

## 拷贝

**直接初始化 vs 拷贝初始化**：

``` c++
string dots(10, '.');              // 直接初始化
string s(dots);                    // 直接初始化
string s1 = dots;                  // 拷贝初始化
string s2 = "9999-99-9";           // 拷贝初始化
string s3 = string(10, '.');       // 拷贝初始化
```

当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。而当我们使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中。

拷贝初始化通常使用拷贝构造函数来完成。但是，如果一个类有一个移动构造函数，那么拷贝初始化有时会使用移动构造函数来完成。

## 移动

**push vs emplace**：

标准库容器中的`push`成员，会对其元素进行拷贝初始化；而`emplace`成员，则会对其元素进行直接初始化。

### std::move

我们还可以通过调用一个名为`std::move`的新标准函数来获得绑定到左值上的右值引用。

我们必须认识到，调用`move`就意味着承诺，除了对这个左值引用赋值或销毁它外，我们将不再使用它。

## 完美转发

当一个右值引用作为函数的形参时，在函数内部再使用该参数时它已经变成一个左值了。因此，我们需要一种方法能按照参数原来的类型转发到另一函数，这种转发被称为完美转发，即：在模板函数中，完全依照模板参数类型，将参数传递给另一个函数。

### std::forward

C++标准库定义了std::forward函数来保证实现完美转发。具体来说，std::forward的功能是：当参数不是一个左值引用时，函数返回一个右值引用；当参数是一个左值引用时，函数什么都不修改直接返回。
# 继承与多态

- [继承与多态](#继承与多态)
  - [继承](#继承)
    - [继承访问控制符](#继承访问控制符)
    - [final 和 override 说明符](#final-和-override-说明符)
  - [多态](#多态)
    - [虚函数 Virtual Function](#虚函数-virtual-function)
      - [纯虚函数](#纯虚函数)
    - [虚表 Virtual Table](#虚表-virtual-table)
    - [静态绑定 vs 动态绑定](#静态绑定-vs-动态绑定)
  - [参考](#参考)

## 继承

**成员函数与继承**

在C++语言中，基类必须将它的两种成员函数分开来：一种是基类希望派生类进行覆盖的虚函数；另一种是派生类直接继承而不要改变的函数。

**静态成员与继承**

如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。

### 继承访问控制符

### final 和 override 说明符

**override**

C++11 新标准中我们可以使用`override`关键字来说明派生类中的虚函数。

这么做的好处是使得程序员的意图更加清晰的同时让编译器为我们发现一些错误。

如果我们使用了`override`标记了某个函数，但该函数没有覆盖已经存在的虚函数，此时编译器会报错。因为如果派生类定义了一个普通（或虚）函数与基类中函数的名字相同但形参列表不同，这仍然是合法的。

**final**

C++11 新标准提供了一种防止继承发生的方法，即在类后跟一个关键字`final`

## 多态

关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。

而所谓的泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。

### 虚函数 Virtual Function

某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成`虚函数(virtual function)`。

**形参和返回类型都必须匹配**

派生类中虚函数的形参和返回类型都必须和基类中匹配。

但该规制存在一个例外，当类的虚函数返回类型是该类本身的指针或引用时，上述规则无效。

**可以在派生类再次声明为virtual**

派生类中的虚函数可以使用`virtual`关键字指出该函数的性质。

**构造函数不能是虚函数**

因为虚函数的作用在于通过父类的指针或引用来调用它的时候变成调用子类的成员函数。

而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用，因此也就规定构造函数不能是虚函数。

**析构函数大多数时候是虚函数**

因为如果虚函数不是虚函数的话，那么在析构一个由父类指针指向的子类对象时，就不会发生动态绑定，也就只能调用父类析构函数，即：无法销毁子类独有的部分元素。

#### 纯虚函数

### 虚表 Virtual Table

在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。

在有虚函数的类的实例中，指向虚表的指针被分配在了这个实例的内存中，且C++的编译器保证虚函数表的指针总是存在于对象实例中最前面的位置。

而虚表本身则是存在类中，使得同一类的不同对象共享。

### 静态绑定 vs 动态绑定

**静态类型 vs 动态类型**

表达式的静态类型在编译时总是已知的 ，它是变量声明时的类型或表达式生成的类型；

动态类型则是变量或表达式表示的内存中对象的类型，动态类型直到运行时才可知。

**静态绑定 vs 动态绑定**

当我们使用基类的引用或指针调用基类定义的一个函数时，我们并不知道该函数真正作用的对象是什么类型，因为它可能是一个基类对象也可能是一个派生类的对象。

+ 如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本，判断依据是引用或指针绑定的对象的真实类型。

+ 而对非虚函数的调用则是在编译时进行绑定。

此外，通过对象进行的函数调用也是在编译时进行绑定，因为对象的类型是确定不变的。

## 参考

**虚函数、虚表、动态绑定**

+ [陈皓-虚函数解析](https://blog.csdn.net/haoel/article/details/1948051)
# 错误 & 异常处理

- [错误 \& 异常处理](#错误--异常处理)
  - [C语言错误处理](#c语言错误处理)
    - [错误码](#错误码)
    - [防御式编程——断言](#防御式编程断言)
    - [第三方异常处理](#第三方异常处理)
  - [C++语言异常处理](#c语言异常处理)
  - [抛出异常](#抛出异常)
    - [栈展开](#栈展开)
    - [析构函数与异常](#析构函数与异常)
    - [异常对象](#异常对象)
  - [捕获异常](#捕获异常)
    - [重新抛出](#重新抛出)
    - [捕获所有异常的处理代码](#捕获所有异常的处理代码)
  - [noexcept异常说明](#noexcept异常说明)
  - [参考](#参考)

## C语言错误处理

传统的C语言缺乏异常处理的能力，它提供了一种更原始的机制，即：返回一个错误码。

### 错误码

在发生错误时，大多数的libc函数调用返回1或NULL，并设置一个错误代码errno，该错误代码是全局变量，表示在函数调用期间发生了错误。

**errno变量**：

在C语言中，errno是一个全局变量，用于表示发生的错误代码。它定义在<errno.h>头文件中，并由标准库函数在发生错误时进行设置。此外，errno.h头文件中还定义了各种各样的错误代码。比如：

- EDOM：这个宏表示一个域错误，它在输入参数超出数学函数定义的域时发生。
- ERANGE：这个宏表示一个范围错误，它在输入参数超出数学函数定义的范围时发生。

**打印错误信息**：

此外，C语言还提供了perror()和strerror()函数来显示与errno相关的文本消息。

- perror()函数显示传给它的字符串，后跟一个冒号、一个空格和当前errno值的文本表示形式。
- strerror()函数，返回一个指针，指针指向当前errno值的文本表示形式。

使用方法如下：

``` c
fprintf(stderr, "错误号: %d\n", errno);
perror("通过 perror 输出错误");
fprintf(stderr, "打开文件错误: %s\n", strerror( errnum ));
```

值得补充的是，C程序默认使用三种标准输入输出。这三种标准输入输出通常分别被称为标准输入（Standard Input）、标准输出（Standard Output）和标准错误（Standard Error）。其中，标准输入文件，通常对应终端的键盘；标准输出文件和标准错误输出文件，这两个文件都对应终端的屏幕。在<stdio.h>头文件中，定义了stdin、stdout、stderr三种宏，它们通常是一个FILE*指针。

### 防御式编程——断言

断言（Assertion）是一种用于检查代码假设和约束的工具。断言通常用于在代码中插入检查点，以确保某个条件为真。如果断言的条件不满足，即为假，程序会中止执行并报告错误。

断言的目的是在开发和调试阶段捕捉可能的错误和逻辑问题，以便尽早发现和修复它们。它们通常用于验证程序中的前置条件、后置条件和不变式等。

``` c++
// C用#include <assert.h>，C++#include<cassert> 
#include<cassert> 
assert(divisor != 0);
```

除此之外，C++ 还引入了static_assert关键字，它用于在编译时进行静态断言检查。

### 第三方异常处理

## C++语言异常处理

`异常处理(exception handling)`机制允许程序出现问题进行通信并做出相应的处理。

## 抛出异常

在C++语音中，我们通过`抛出(throwing)`一条表达式来引发一个异常。

当执行一个throw时，跟在throw后面的语句将不再被执行。相反，程序的控制权从throw转移到与之匹配的catch模块。这里有两个重要的含义：

- 函数可能提早退出；
- 一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁。

### 栈展开

当throw出现在一个try语句块内时，检查与该try块关联的catch子句。

栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的catch子句为止；或者也可能一直没找到匹配的catch，则退出主函数后查找过程终止。

栈展开过程中对象会自动被销毁。

### 析构函数与异常

### 异常对象

`异常对象(exception object)`是一种特殊的对象，编译器使用异常抛出表达式对异常对象进行拷贝初始化。

## 捕获异常

`catch子句(catch clause)`中异常声明看起来像只包含一个形参的函数形参列表。

声明类型决定了处理代码所能捕获的异常类型。这个类型必须是完全类型，它可以是左值引用，但不能是右值引用。

### 重新抛出

一条catch语句通过重新抛出的操作将异常传递给另一个catch语句。这里的重新抛出仍然是一条throw语句，只不过不包含任何表达式。

### 捕获所有异常的处理代码

形如catch(...)，一条语句可以与任意类型的异常匹配。

## noexcept异常说明

在C++11新标准中，我们可以通过提供`noexcept说明`指定某个函数不会抛出异常。

## 参考

[C++ Primer](https://zhjwpku.com/assets/pdf/books/C++.Primer.5th.Edition_2013.pdf)

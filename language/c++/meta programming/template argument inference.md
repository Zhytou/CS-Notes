# 模板参数推断

- [模板参数推断](#模板参数推断)
  - [从左值引用函数参数推断类型](#从左值引用函数参数推断类型)
  - [从右值引用函数参数推断类型](#从右值引用函数参数推断类型)
  - [引用折叠和右值引用参数](#引用折叠和右值引用参数)
    - [引子](#引子)
    - [第一种规则](#第一种规则)
    - [第二种规则——引用折叠](#第二种规则引用折叠)

## 从左值引用函数参数推断类型

**非const型**：

``` c++
template <typename T> void f(T&);//实参必须是一个左值
f(i);//i是一个int，模板参数T是int
f(ci);//ci是一个int，模板参数T是const int
f(5);//错误，实参必须是左值
```

**const型**：

``` c++
template <typename T> void f2(const T&);//可以接收一个右值
f2(i);//i是一个int，模板参数T是int
f2(ci);//ci是一个const int，但模板参数T是int
f2(5);//一个const& 参数可以绑定到一个右值，模板参数T是int
```

## 从右值引用函数参数推断类型

推断过程类似左值引用函数。

``` c++
template <typename T> void f3(T&&);
f3(42); // 实参是一个int类型的右值，模板参数T是int
```

## 引用折叠和右值引用参数

### 引子

``` c++
template <typename T> void f3(T&&);
f3(i);// 正确，因为引用迭代
```

看上述例子，`i`作为一个int对象，理论上`f3(i)`这样的调用应该不合法。毕竟，`i`是一个左值，而通常我们不能将一个右值引用绑定到一个左值上去。

但C++定义了两种特殊的规则，允许这种绑定。此外，这两个例外的规则还是`std::move`这种标准库设施的工作基础。

### 第一种规则

第一例外规则影响右值引用参数的推断进行。

当我们将一个左值传递给右值引用参数，且此右值引用指向模板类型参数（如T&&）时，编译器推断模板类型参数为实参的左值引用类型。

因此当我们调用`f3(i)`时，编译器推断T的类型为int&，而非int。

### 第二种规则——引用折叠

在这种情况下，我们可以使用使用第二个例外的绑定规则：

如果我们简介创建了一个引用的引用，则这些引用形成了“折叠”。在这种情况下（一个例外），引用会折叠成以恶搞普通的左值引用。即，对于一个给定类型X：

- X& &、X& &&和X&& &都折叠成类型&；
- 类型X&& &&折叠成X&&。

在这种规则下，我们将得到一个惊人的结果，即：如果一个函数参数是指向模板参数类型的右值引用，则可以传递给他任意类型的实参。

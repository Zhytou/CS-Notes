# 右值：移动和转发

- [右值：移动和转发](#右值移动和转发)
  - [右值](#右值)
  - [移动语义](#移动语义)
    - [右值引用](#右值引用)
    - [移动构造](#移动构造)
    - [std::move](#stdmove)
  - [完美转发](#完美转发)
    - [什么是转发](#什么是转发)
    - [std::forward](#stdforward)
    - [参数推断和引用折叠](#参数推断和引用折叠)

## 右值

在C++语言中，所有具有名字的对象或变量都是左值(lvalue)，而**不可寻址**临时对象或字面量等则被视为右值(rvalue)。实际上，右值分成两种：

- 纯右值(prvalue，pure right value):是一种临时的、无需标识的右值，例如字面值常量、临时对象等。
- 将亡值(xvalue，expiring value):是一种即将被销毁、但仍然可以访问其内部成员的右值。通常是通过 std::move 转换得到的。

## 移动语义

移动语义(move semantics)是C++11引入的一个重要特性，旨在提高对临时对象的效率。通过移动语义，可以将临时对象的资源（如内存所有权）转移给另一个对象，而无需进行深层次的复制操作。

### 右值引用

为了支持移动操作，C++11引入了一种新的引用类型——右值引用(rvalue reference)，即绑定到右值的引用。为了和其区分开来，可以将C++98中的普通引用称之为左值引用(lvalue reference)。

类似左值引用，一个右值引用也不过是某个对象的另一个名字而已。不过因为右值总是没有名字，所以往往只能通过其引用找到它。

除此之外，右值引用还有一个重要的性质，即只能绑定到将亡右值上。因此，我们不能将其绑定到要求转化的表达式、字面常量或是返回右值的表达式。

### 移动构造

在C++中，一个对象通常可以通过构造函数和赋值运算符进行初始化。其中，移动构造函数和移动赋值运算符是用于实现移动语义的重要工具。移动构造函数接受一个右值引用作为参数，用于接管另一个对象的资源，并将其销毁。移动赋值运算符也是类似的，用于在赋值时将右值的资源转移到左值。

### std::move

我们还可以通过调用一个名为`std::move`的新标准函数来获得绑定到左值上的右值引用。我们必须认识到，调用`move`就意味着承诺，除了对这个左值引用赋值或销毁它外，我们将不再使用它。

## 完美转发

### 什么是转发

在C++中，转发指的就是函数之间的参数传递。有些时候，参数在函数间传递时属性可能会发生改变。比如：

```c++
void innerFunc1(int& x) {
  x += 1;
}

void func1(int x) {
  innerFunc1(x);
}

int main() {
  func1(0);
}
```

上述例子中，innerFunc1对参数的修改无法传递到main函数中，因为innerFunc1得到的只是func1生成的一个副本。又比如：

```c++
void innerFunc2(int&& x) {
  // ...
}

void func2(int&& x) {
  innerFunc2(x);
}

int main() {
  func2(2);
}
```

这个例子的代码甚至不能编译通过，因为func2中的x参数是一个右值引用，即左值（对，没错，右值引用是一个左值，因为它可以求地址），而innerFunc2要求传入一个右值。

可见，我们需要一种方法能按照参数原来的类型转发到另一函数，这种转发被称为完美转发，即：在模板函数中，完全依照模板参数类型，将参数传递给另一个函数。

### std::forward

C++标准库定义了std::forward函数来保证实现完美转发。具体来说，std::forward的功能是：当参数不是一个左值引用时，函数返回一个右值引用；当参数是一个左值引用时，函数什么都不修改直接返回。

### 参数推断和引用折叠

模板编程中参数推断的规则，尤其是万能引用(T&&)的推断，是std::forward得以实现的基础。

**左值引用参数推断**:

要想理解引用折叠，我们首先来看模板函数中参数为左值引用(T&)的情况。

``` c++
template <typename T> void f(T&);//实参必须是一个左值
f(i);  //i是一个int，模板参数T是int
f(5);  //错误，实参必须是左值
```

从上可见，当模板函数参数为左值引用(T&)时，它要求传入参数必须是一个左值，否则就会编译报错。

**右值引用参数推断**：

至于右值引用(T&&)的情况就要复杂一些了，因为它可以接收任何参数，所以也得名万能引用。比如：

```c++
int i;
int& ii = i;
template <typename T> void f(T&&);
f(42); // 实参是一个int类型的右值，模板参数T是int
f(i); // 正确
f(ii); // 正确
```

看上述例子，i作为一个int对象而ii作为一个int引用，理论上f(i)和f(ii)这样的调用应该不合法。毕竟，我们一般不会将一个右值引用绑定到一个左值或左值引用上去。但C++定义了两种特殊的规则允许这种绑定。

- 将一个左值传递给右值引用参数(T&&)时，编译器推断模板类型参数为实参的左值引用类型(T&)。换句话说，调用f(i)时，编译器推断T的类型为int&。
- 将一个左值引用传递给右值引用参数(T&&)时，编译器会进行引用折叠，得到模板类型参数为实参的左值引用类型(T&)。换句话说，调用f(ii)时，编译器推断T的类型也为int&。

**引用折叠**：

事实上，上述参数推断只用到了部分引用折叠规则。完整的引用折叠规则包括：

- X& &、X& && 和 X&& & 都会折叠为 X&。
- X&& && 会折叠为 X&&。

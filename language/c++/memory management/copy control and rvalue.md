# 拷贝控制

- [拷贝控制](#拷贝控制)
  - [拷贝](#拷贝)
  - [移动](#移动)
    - [std::move](#stdmove)
  - [右值](#右值)
    - [右值引用](#右值引用)
  - [完美转发](#完美转发)
    - [std::forward](#stdforward)

## 拷贝

**直接初始化 vs 拷贝初始化**：

``` c++
string dots(10, '.');              // 直接初始化
string s(dots);                    // 直接初始化
string s1 = dots;                  // 拷贝初始化
string s2 = "9999-99-9";           // 拷贝初始化
string s3 = string(10, '.');       // 拷贝初始化
```

当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。而当我们使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中。

拷贝初始化通常使用拷贝构造函数来完成。但是，如果一个类有一个移动构造函数，那么拷贝初始化有时会使用移动构造函数来完成。

## 移动

**push vs emplace**：

标准库容器中的`push`成员，会对其元素进行拷贝初始化；而`emplace`成员，则会对其元素进行直接初始化。

### std::move

我们还可以通过调用一个名为`std::move`的新标准函数来获得绑定到左值上的右值引用。

我们必须认识到，调用`move`就意味着承诺，除了对这个左值引用赋值或销毁它外，我们将不再使用它。

## 右值

在C++语言中，右值一般是不可寻址的常量或临时创建对象。所有具有名字的对象或变量都是左值。实际上，右值分成两种：一个是将亡值（xvalue，expiring value），另一个是纯右值（prvalue，pure right value）。

### 右值引用

为了支持移动操作，新标准引入了一种新的引用类型——右值引用(rvalue reference)。这是因为右值没有名字，只能通过引用找到它。

右值引用就是绑定到右值的引用。

我们通过 && 而不是 & 来获取右值引用。

右值引用有一个重要的性质，只能绑定到一个将要销毁的对象。

类似任何引用，一个右值引用也不过是某个对象的另一个名字而已。

对于常规引用（为了和右值引用区分开来，我们可以将其称之为`左值引用(lvalue reference)`），我们不能将其绑定到要求转化的表达式、字面常量或是返回右值的表达式。

## 完美转发

当一个右值引用作为函数的形参时，在函数内部再使用该参数时它已经变成一个左值了。因此，我们需要一种方法能按照参数原来的类型转发到另一函数，这种转发被称为完美转发，即：在模板函数中，完全依照模板参数类型，将参数传递给另一个函数。

### std::forward

C++标准库定义了std::forward函数来保证实现完美转发。具体来说，std::forward的功能是：当参数不是一个左值引用时，函数返回一个右值引用；当参数是一个左值引用时，函数什么都不修改直接返回。

# 继承与多态

- [继承与多态](#继承与多态)
  - [继承](#继承)
    - [继承访问控制符](#继承访问控制符)
    - [final 和 override 说明符](#final-和-override-说明符)
  - [多态](#多态)
    - [分类](#分类)
    - [实现](#实现)
    - [静态绑定 vs 动态绑定](#静态绑定-vs-动态绑定)
  - [虚函数 Virtual Function](#虚函数-virtual-function)
    - [纯虚函数](#纯虚函数)
    - [虚表 Virtual Table](#虚表-virtual-table)
  - [参考](#参考)

## 继承

**成员函数与继承**：

在C++语言中，基类必须将它的两种成员函数分开来：一种是基类希望派生类进行覆盖的虚函数；另一种是派生类直接继承而不要改变的函数。

**构造函数与继承**：

尽管派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。派生类必须使用基类的构造函数来初始化它基类的部分。

构造函数的执行顺序：

- 调用基类构造函数。

- 对初始化列表中的成员进行初始化。

- 执行派生类的构造函数体中的内容。

**静态成员与继承**：

如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。

**友元与继承**：

基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。

**模板与继承**：

见[模板与泛型编程总结](/language/c++/basical/template%20and%20generic%20programming.md)

### 继承访问控制符

**继承控制**：

某个类对其继承而来的成员的访问权限受到两个因素影响：一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。

- `public`
- `protected`
- `private`

其中，`class`关键字默认是私有继承；而`struct`关键字默认使用共有继承。

**改变个别成员的可访问性**：

我们可以通过使用`using`声明改变继承的某个名字的访问级别。

### final 和 override 说明符

**override**：

C++11 新标准中我们可以使用`override`关键字来说明派生类中的虚函数。

这么做的好处是使得程序员的意图更加清晰的同时让编译器为我们发现一些错误。

如果我们使用了`override`标记了某个函数，但该函数没有覆盖已经存在的虚函数，此时编译器会报错。因为如果派生类定义了一个普通（或虚）函数与基类中函数的名字相同但形参列表不同，这仍然是合法的。

**final**：

C++11 新标准提供了一种防止继承发生的方法，即在类后跟一个关键字`final`。

## 多态

关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。

而所谓的泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。

### 分类

C++中多态可以分成四类：

- 参数多态：函数模板和类模板
- 包含多态：虚函数
- 重载多态：函数重载、运算符重载
- 强制多态：指将一个变元的类型加以变化，以符合一个函数或操作的要求

### 实现

在C++中，多态的实现和联编这一概念有关。

所谓联编就是把函数名与函数体的程序代码连接(联系)在一起的过程。

- 静态联编就是在编译阶段完成的联编。
- 动态联编是运行阶段完成的联编。

纯粹的面向对象程序设计语言由于其执行机制是消息传递，所以只能采用动态联编。这就给基于C语言的 C++ 带来了麻烦。因为为了保持C语言的高效性，C++仍是编译型的，仍采用静态联编。好在 C++ 的设计者想出了“虚函数” 的机制，解决了这个问题。利用虚函数机制，C++ 可部分地采用动态联编。这就是说，C++ 实际上是采用了静态联编和动态联编相结合的联编方法。

在C++中， 编译时多态性主要是通过函数重载和运算符重载实现的。 运行时多态性主要是通过虚函数来实现的。

### 静态绑定 vs 动态绑定

**静态类型 vs 动态类型**：

表达式的静态类型在编译时总是已知的 ，它是变量声明时的类型或表达式生成的类型；

动态类型则是变量或表达式表示的内存中对象的类型，动态类型直到运行时才可知。

**静态绑定 vs 动态绑定**：

当我们使用基类的引用或指针调用基类定义的一个函数时，我们并不知道该函数真正作用的对象是什么类型，因为它可能是一个基类对象也可能是一个派生类的对象。

- 如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本，判断依据是引用或指针绑定的对象的真实类型。
- 而对非虚函数的调用则是在编译时进行绑定。

此外，通过对象进行的函数调用也是在编译时进行绑定，因为对象的类型是确定不变的。

## 虚函数 Virtual Function

某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成`虚函数(virtual function)`。

**形参和返回类型都必须匹配**：

派生类中虚函数的形参和返回类型都必须和基类中匹配。

但该规制存在一个例外，当类的虚函数返回类型是该类本身的指针或引用时，上述规则无效。

**可以在派生类再次声明为virtual**：

派生类中的虚函数可以使用`virtual`关键字指出该函数的性质。

**构造函数不能是虚函数**：

因为虚函数的作用在于通过父类的指针或引用来调用它的时候变成调用子类的成员函数。

而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用，因此也就规定构造函数不能是虚函数。

**析构函数大多数时候是虚函数**：

因为如果虚函数不是虚函数的话，那么在析构一个由父类指针指向的子类对象时，就不会发生动态绑定，也就只能调用父类析构函数，即：无法销毁子类独有的部分元素。

**回避虚函数机制**：

在某些情况下，我们希望对虚函数的调用不进行动态绑定，而是强迫其执行虚函数的某个版本。使用作用域运算符可以实现这一目的。

### 纯虚函数

通过在函数体的位置处书写`=0`可以将一个虚函数声明为纯虚函数。

**抽象基类**：

含有纯虚函数的类是抽象基类。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能直接创建一个抽象基类的对象。

### 虚表 Virtual Table

在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。

在有虚函数的类的实例中，指向虚表的指针被分配在了这个实例的内存中，且C++的编译器保证虚函数表的指针总是存在于对象实例中最前面的位置。

而虚表本身则是存在类中，使得同一类的不同对象共享。

## 参考

**虚函数、虚表、动态绑定**：

- [陈皓-虚函数解析](https://blog.csdn.net/haoel/article/details/1948051)

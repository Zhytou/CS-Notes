# C++ History

## C++98

## C++11

- 来自C++ Primer第五版的内容

### constexpr 变量

- C++11 新标准规定，允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量表达式。

### auto 类型说明符

- C++11 新标准引入了`auto`类型说明符，用它就能让编译器替我们去分析表达式所属的类型。
- `auto`让编译器通过初始值来推算变量的类型。因此，`auto`定义的变量必须初始值。

### decltype 类型指示符

- C++11 新标准引入了第二种类型说明符`decltype`，它们的作用是选择并返回操作数的数据类型。

### 类内初始值

- C++11 新标准规定，可以为数据成员提供一个类内初始值。
- 创建对象时，类内初始值将用于初始化数据成员。

### 列表初始化 vector 对象

- C++有好几种不同的初始化方式：
  - 默认初始化
    - 对内置类型来说，它的默认初始化由它定义的位置决定：定义在函数外的被初始化为0；其他均不被初始化。
    - 对其他类型来说，每个类各自决定其初始化方式。
  - 直接初始化：不使用等号初始化一个变量
  - 拷贝初始化：使用等号初始化一个变量
- C++11 新标准提供了一种列表初始化的方法。

### initializer_list 形参

- 为了能编写能处理不同实参的函数，C++11 新标准提供了两种主要的方法：
  - ==如果所有实参类型相同==，可以传递一个名为`initializer_list`的标准库类；
  - 如果实参类型不同，我们可以编写一种特殊函数，也就是所谓的可变参数模板。
- `initializer_list`是一种标准库类型，用于表示某种特定类型的值的数组。`initializer_list`就放在名为`initializer_list`的库内。
  - 定义`initializer_list`必须说明所含元素类型；
  - `initializer_list`对象中的元素永远是常量值；
  - 含有`initializer_list`形参的函数也可以同时拥有其他形参。

### 列表初始化返回值

- C++11 新标准规定，函数可以返回花括号包围的值列表。

### Constexpr 函数

- `constexpr` 函数是指用于常量表达式的函数。

- 定义`constexpr` 函数的方法与其他函数类似，不过要遵守几项约定：
  
  - 函数的返回类型及所有形参的类型都是字面值类型；

    > 常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”（literal type）。
  
  - 函数必须有且只有一条返回语句。

### Constexpr 构造函数

- 尽管构造函数不能是`const`的，但字面值常量类的构造函数可以是`constexpr`函数。

### Lambda 函数

- 一个`lambda`表达式一般具有如下形式：
  
  ```C++
  [capture list](parameter list) -> return type { function body }
  ```

- 其中，捕获列表是一个`lambda`所在函数中定义的局部变量列表；

- 我们可以忽略参数列表和返回类型，但必须要包含捕获列表和函数体；

- `lambda`的调用方式与普通函数的调用方式相同，都是使用调用运算符。

### 智能指针

- 为了更安全地使用动态内存，C++11 标准提供了两种智能指针类型来管理动态对象。

### Final 阻止继承发生

- C++11 新标准提供了一种防止继承发生的方法，即在类后跟一个关键字`final`。

## C++14

## C++17

# 接口

- [接口](#接口)
  - [概述](#概述)
    - [底层实现](#底层实现)
  - [类型转换](#类型转换)
    - [类型断言](#类型断言)
  - [空接口](#空接口)

## 概述

**实现接口的条件**:

Go 语言中接口的实现都是*隐式的*，一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。

**一个类型可以实现多个接口**：

一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。

### 底层实现

**接口分类**：

Go 语言根据接口类型是否包含一组方法将接口类型分成了两类：

- 使用 runtime.iface 结构体表示包含方法的接口
- 使用 runtime.eface 结构体表示不包含任何方法的 interface{} 类型

**数据结构**：

``` golang
type eface struct { // 16 字节
 _type *_type
 data  unsafe.Pointer
}

type iface struct { // 16 字节
 tab  *itab
 data unsafe.Pointer
}
```

## 类型转换

### 类型断言

Go语言中使用`接口断言（type assertions）`将接口转换成另外一个接口，也可以将接口转换为另外的类型。

**断言格式**：

``` txt
t := i.(T)
```

**使用例子**：

``` golang
// 声明a变量, 类型int, 初始值为1
var a int = 1

// 声明i变量, 类型为interface{}, 初始值为a, 此时i的值变为1
var i interface{} = a

// 声明b变量，类型int, 赋值时先进行了类型断言
var b int = i.(int)
```

## 空接口

空接口是接口类型的特殊形式，空接口没有任何方法，因此任何类型都无须实现空接口。从实现的角度看，任何值都满足这个接口的需求。因此空接口类型可以保存任何值，也可以从空接口中取出原值。

个人感觉，类似 C 语言的`void *`。当想要将值从空接口变量中取出来时，先执行类型断言。这一点类似使用C语言中malloc函数时，先将返回的`void *`指针转换成对应类型指针。

需要注意的是，与 C 语言中的`void *`不同，interface{} 类型不是任意类型。如果我们将类型转换成了 interface{} 类型，变量在运行期间的类型也会发生变化，获取变量类型时会得到 interface{}。

[接口底层实现](https://halfrost.com/go_interface/#toc-0)

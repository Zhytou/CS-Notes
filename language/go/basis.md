# 基础

- [基础](#基础)
  - [变量](#变量)
    - [指针 \& new函数](#指针--new函数)
  - [常量](#常量)
  - [类型](#类型)
    - [内置类型](#内置类型)
    - [引用类型](#引用类型)
    - [自定义类型](#自定义类型)
  - [语句](#语句)
    - [for](#for)
    - [defer](#defer)
  - [操作](#操作)
    - [函数](#函数)
    - [方法](#方法)
    - [接口](#接口)
  - [并发](#并发)
  - [包](#包)
  - [参考](#参考)

Go语言主要有四种类型的声明语句：`var`、`const`、`type`和`func`，分别对应变量、常量、类型和函数实体对象的声明。

## 变量

关键字`var`用于定义变量，类型被放在变量名后面。另外，运行时内存分配操作会确保变量自动初始化为二进制零值。

变量声明的一般语法如下：

``` txt
var 变量名字 类型 = 表达式
```

如果显式提供初始化值，可省略变量类型，由编译器推断。

**简短变量声明**：

除`var`关键字外，还可以使用更加简短的变量定义和初始化语法，不过有以下限制：

- 定义变量，同时显示初始化。
- 不能提供数据类型。
- 仅用在函数内部。

总的来说，Go有四种变量声明方法：

- 声明一个变量，默认是0 `var a int`
- 声明一个变量，初始化一个值 `var b int = 100`
- 声明一个变量，省去类型，通过自动匹配判断数值类型 `var c = 100`
- 省去关键字var，但只能够用于函数体内 `d := 100`

### 指针 & new函数

另一个创建变量的方法是调用用内建的new函数。表达式`new(T)`将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为 *T 。

用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外。也就是说，new函数是一种语法糖，而不是一个新的基础概念。

此外，应当注意的是每次调用new函数都是返回一个新的变量的地址。

## 常量

常量必须是编译期可确定的字符、字符串、数字或布尔值。可以指定常量类型，也可以由编译器通过初始化值推断。

在常量组中如不指定类型和初始化值，则与上一行非空右值相同。

``` go
const {
    x int = 100
    y   // 与上一行x类型相同、右值相同
    s = "abc"
    t   // 与上一行s类型相同、右值相同
}
```

Go并没有枚举类型的定义，不过可以借助`iota`标识符实现一组自增常量值来实现枚举类型。

``` go
const {
    x = iota // 0
    y        // 1
    z        // 2
}
```

## 类型

Go语言将数据类型分为四类：

- 基础类型：数字、字符串和布尔型；
- 复合类型：数组和结构体；
- 引用类型：切片、字典、函数和通道；
- 接口类型：一组方法的集合。

### 内置类型

数字类型、字符串和布尔类型

### 引用类型

所谓的引用类型，主要是指`切片slice`、`字典map`和`通道channel`三种类型（还包括`接口interface`和`函数function`，注意`字符串string`原则上来讲也属于引用类型）。

引用类型比内置类型拥有更复杂的存储结构。除了分配内存外，它们还需要初始化一系列属性。

- `内置函数new`依照指定类型数据长度分配内存，返回指针。
- 引用类型则必须使用`make函数`创建。

### 自定义类型

使用`关键字type`定义用户自定义类型，包括基于现有类型创建、或创建结构体、函数等。注意，此处不同于类型别名，尽管可能新类型与内置类型完全相同：

- `type TypeAlias = xxx` 定义别名语法
- `type NewType xxx` 定义新类型语法

## 语句

Go语句加分号和不加分号都可以

### for

``` golang
// 类似 while
for i < 200 {
  //
}

// 基础用法
for i := 0; i < len(arr); i++ {
  //
}

// 配合range
for idx, val := range arr {
  //
}
```

### defer

- 多个defer语句满足先进后出的规则
- 在return之后执行

## 操作

### 函数

在Go语言中，函数是一等公民。它可以像其他值一样被传递、赋值、比较和返回。

### 方法

方法是与对象实例绑定的特殊函数。与函数不同，方法是有状态的。

在Go中，可以为当前包内除了接口和指针之外的任何类型定义方法。

### 接口

Go语言不是一种 “传统” 的面向对象编程语言：它里面没有类和继承的概念。

在某些动态语言里，`接口(interface)`也被称作`协议(protocol)`。准备交互的双方，共同遵守事先约定的规则，使得在无需知道对方身份的情况下，进行协作。

从内部实现来看，接口自身也是一种结构类型，只是编译器会对其做出限制（类似JAVA接口和C++纯虚函数类实现接口）。

- 不能有字段。
- 不能定义自己的方法。
- 只能声明方法，不能实现。
- 可以嵌入其他接口类型。

Go的接口实现机制很简单，只要目标类型方法集内包含接口声明的全部方法就被视为实现了该接口，无需像JAVA里做`implement`的显式声明。

此外，目标类型也可以同时实现多个接口。

接口习惯以`er`作为名称后缀，方法名是声明组成部分，但参数名可不同或省略。

``` go
type tester interface {

}
```

## 并发

不要通过共享内存来通信，而要通过通信来实现内存共享。这就是Go语言的并发哲学，它依赖`CSP(Communicating Sequential Processe)s`模型，基于channel实现。

## 包

`包(package)`由一个或多个在同一目录下（不含子目录）的源文件组成。包的用途类似`名字空间(namespace)`，是成员作用域和访问权限边界。

包与所在目录名无关。虽说习惯保持一致，但并非硬性规定。

所有成员在包内均可访问，无论是否在同一源码文件中。但只有名称首字母大写的为可导出成员，在包外可视。

类似Java， Go语言需要定义一个main包，用于标识程序入口的包。其中包含了一个程序的主函数。

``` golang
package main

import "fmt"

func main() {
    fmt.Print("Hello world!")
}
```

## 参考

[Go语言圣经](https://books.studygolang.com/gopl-zh/)

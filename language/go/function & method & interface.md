# 函数 & 方法 & 接口

- [函数 \& 方法 \& 接口](#函数--方法--接口)
  - [函数](#函数)
    - [函数声明](#函数声明)
    - [函数值](#函数值)
  - [方法](#方法)
    - [方法声明](#方法声明)
    - [基于指针对象的方法](#基于指针对象的方法)
    - [方法值与方法表达式](#方法值与方法表达式)
  - [接口](#接口)
    - [接口约定](#接口约定)
    - [接口类型](#接口类型)
    - [实现接口的条件](#实现接口的条件)

## 函数

### 函数声明

``` txt
func name(parameter-list) (result-list) {
    body
}
```

**参数传递**：

实参通过值的方式传递，因此函数的形参是实参的拷贝。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如指针，slice(切片)、map、function、channel等类型，实参可能会由于函数的简介引用被修改。

**非Go实现的函数声明**：

某些没有函数体的函数声明表示该函数不是以Go实现的。

### 函数值

函数的类型被称为函数的标识符。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型和标识符。

在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。例如：

``` golang
var f func(int) int

func negative(n int) int { return -n }

f = negative
fmt.Println(f(3)) 
```

**函数值做参数**：

``` golang
func add1(r rune) rune { return r + 1 }
fmt.Println(strings.Map(add1, "HAL-9000")) 
```

## 方法

### 方法声明

在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。例如：

``` golang
type Point struct {X, Y float64}

func (p Point) Distance(q Point) float64 {
  ...
}
```

**接收器**：

上面的代码里那个附加的参数p，叫做方法的接收器(receiver)，早期的面向对象语言留下的遗产将调用一个方法称为“向一个对象发送消息”。

在Go语言中，我们并不会像其它语言那样用this或者self作为接收器；我们可以任意的选择接
收器的名字。

**选择器**：

这种p.Distance的表达式叫做选择器，因为他会选择合适的对应p这个对象的Distance方法来执行。

此外，选择器也会被用来选择一个struct类型的字段。因此，当字段和方法重名时，编译器就会报错。

**任意类型都可以定义方法**：

方法可以被声明到任意类型，只要不是一个指针或者一个interface。

因此，在Go语言里，我们为一些简单的数值、字符串、切片、字典来定义一些附加行为很方便。

这个特性使得，相比与在包外调用函数，Go语言调用方法更方便。（在包外调用函数需要写全包名）

### 基于指针对象的方法

**使用指针做函数参数的优势**：

当调用一个函数时，会对其每一个参数值进行拷贝。

如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针了。

**编译器优化**：

当方法接收器为指针类型时，我们仍然可以使用`p.Distance(q)`去调用该方法，因为编译器会隐式地为我们解引用，取到指针指向的实际变量

### 方法值与方法表达式

## 接口

### 接口约定

### 接口类型

接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。

### 实现接口的条件

一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。

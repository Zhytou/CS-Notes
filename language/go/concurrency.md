# 并发

- [并发](#并发)
  - [并发编程综述](#并发编程综述)
    - [多进程编程](#多进程编程)
    - [多线程编程](#多线程编程)
  - [Go语言并发编程](#go语言并发编程)
    - [Go语言并发编程模型](#go语言并发编程模型)
    - [Goroutine](#goroutine)
    - [Channel](#channel)

## 并发编程综述

### 多进程编程

**进程**：

通常，一个程序的执行被称为一个进程；反过来讲，进程用于描述程序执行过程。因此，进程和程序组成了一对相依的概念。

此外，进程还是操作系统进行资源分配的基本单元。

**进程的标识**：

进程的描述符不是一个简单的符号，而是由多种信息（进程优先级、状态、虚拟地址以及访问权限等等）组成的一个复杂数据结构。

而被保存在其中的进程ID（PID）则可以认为是进程在操作系统中的唯一标识。

**进程的空间**：

操作系统将物理内存划分为用户空间和内核空间。

> 操作系统内核是操作系统的核心部分，它是位于操作系统最底层的软件组件，主要负责管理计算机硬件和提供基本系统服务，例如进程管理、内存管理、文件系统管理、设备驱动程序等。
> 操作系统内核通常是一个庞大的软件系统，由多个模块构成，每个模块实现不同的功能。常见的操作系统内核类型包括：宏内核、微内核和混合内核。

**系统调用**：

为了使用户进程能够使用操作系统更底层的功能，内核会暴露出一些接口以供它们使用。

为了保证操作系统的稳定和安全，内核依据由CPU提供的、可以让进程驻留的特权级别建立了两种特权状态，即；内核态和用户态。

当CPU处于用户态时，只能对用户空间访问；当CPU处于用户态时，能对用户空间和内核空间访问。

因此，当用户进程发起一个系统调用时，CPU会从用户态切换至内核态，再执行完相应的内核操作后，再切换回用户态。

**进程间通信**：

在多进程程序中，各个程序的协作通常依靠`进程间通讯IPC(Interprocess Communication)`来完成。

Linux系统中，IPC被分成三大类：

- 基于通讯的IPC方法
  - 以数据传输为手段：管道和消息队列
  - 以共享内存为手段
- 基于信号的IPC方法
  - IPC中唯一一种异步的通讯方法
  - 本质是用软件来模拟硬件的中断机制
    > 硬件中断机制是计算机系统中一种重要的硬件特性，主要用于处理来自外部设备的异步事件，例如键盘输入、鼠标移动或网络数据包的到达等。当硬件设备发生这些异步事件时，它会向处理器发出一个中断信号，以通知处理器有事件需要被处理。处理器在接收到中断信号后会暂停当前正在执行的任务，并跳转到预先设定好的中断处理程序中去处理这个中断事件
- 基于同步的IPC方法
  - 信号量
  - 互斥量（一种特殊的信号量，只有锁定和非锁定两种状态）
  - 条件变量

### 多线程编程

**线程的标识**：

和进程类似，线程也有属于自己的ID（TID），但线程ID在系统范围内可以不是唯一的，它只在所属的进程范围内唯一。

**线程实现模型**：

线程的实现模型主要有3个，它们之间最大的区别就是与`内核调度实体KSE(Kernel Scheduling Entity)`的对应关系。顾名思义，内核调度实体就是可以被内核调度器调度的对象，也就是操作系统内核的最小调度单元。

- 用户级线程模型；用户级线程模型是由用户程序库提供的线程管理机制，内核不直接支持线程。在这种模型下，用户线程的创建、调度、同步、通信等操作都由用户程序库完成，内核只负责进程的管理和调度。用户级线程模型的优点是轻量级、灵活性高，但是缺点是无法利用多核处理器的优势，因为内核无法感知并发执行的用户线程。
- 内核级线程模型：内核级线程模型是由内核提供的线程管理机制，内核负责线程的创建、调度、同步、通信等操作。在这种模型下，每个线程都有对应的内核线程，内核可以感知并发执行的内核线程并进行调度。内核级线程模型的优点是能够充分利用多核处理器的优势，缺点是线程切换的开销较大，且线程同步和通信需要通过内核来完成，效率较低。
- 两级线程模型；：混合线程模型是用户级线程模型和内核级线程模型的结合，既可以利用用户级线程模型的轻量级和灵活性，又可以利用内核级线程模型的多核处理器优势。在混合线程模型下，每个进程可以有多个用户线程，由用户程序库进行管理，同时每个用户线程对应一个内核线程，由内核进行调度。当一个用户线程被阻塞时，它对应的内核线程可以继续执行其他用户线程，从而提高系统的并发能力和吞吐量。

**线程同步**：

- 共享内存
- 互斥量
- 条件变量

## Go语言并发编程

### Go语言并发编程模型

Go语言在操作系统提供的内核线程上搭建了一个特有的两级线程模型。由此，也引出了Goroutine这个特有名词。

### Goroutine

Goroutine的含义：不要用共享内存的方式来通信；使用通讯作为手段来共享内存。

### Channel

**定义**：

通道与切片和字典类型类似，是引用类型之一。它可以分为双向、只发生和只接收三种类型。

因为通道是一个引用类型，所以在初始化前它的值一定是一个`nil`。

``` go
// 声明了一个双向传输int的通道
var ch chan int
// 声明了一个只接收int的通道
var ch1 chan<- int
// 声明了一个只发送int的通道
var ch2 <-chan int

// 创建了一个双向传输int的通道
ch3 := make(chan int)
// 创建了一个带有长度为10缓存区的通道
ch4 := make(chan int, 10)
```

**发送 & 接收**；

``` go
// 接收数据
elem := <-ch

// 发生数据
ch <-= elem
```

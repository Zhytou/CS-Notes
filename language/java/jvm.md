# JVM

- [JVM](#jvm)
  - [JVM Runtime Data Areas](#jvm-runtime-data-areas)
    - [PC Register](#pc-register)
    - [JVM Stack](#jvm-stack)
    - [Native Method Stack](#native-method-stack)
    - [Heap](#heap)
    - [Method Area](#method-area)
    - [Runtime Constant Pool](#runtime-constant-pool)
  - [Java Class File](#java-class-file)
    - [Class File Structure](#class-file-structure)
    - [ByteCode Instruction](#bytecode-instruction)
  - [Class Loading Mechanism](#class-loading-mechanism)
    - [Class Loading Process](#class-loading-process)
    - [Class Loader](#class-loader)
  - [GC](#gc)
    - [Marking](#marking)
    - [Reference](#reference)
    - [GC Algorithm](#gc-algorithm)
    - [Garbage Collector](#garbage-collector)

## JVM Runtime Data Areas

因为Java可移植性，所以像C一样采用操作系统提供的运行时地址空间在JVM是不可取的。JVM提供了一套自己的运行时内存划分机制，它在执行Java程序时会把它管理的内存划分为若干个不同的数据区域，如图所示。

![JVM运行时数据区](https://pdai.tech/images/jvm/jvm/0082zybply1gc6fz21n8kj30u00wpn5v.jpg)

这些区域大体上可以按线程私有或共享分为两部分：

- 线程私有：程序计数器、虚拟机栈、本地方法区
- 线程共享：堆、方法区, 堆外内存（Java7的永久代或JDK8的元空间、代码缓存）

此外，JVM运行时数据区同样随着JDK版本变换而变化。如下图所示，JDK 1.6、JDK 1.7、JDK 1.8的内存划分都会有所不同。

![不同JDK的运行时数据区](https://s2.51cto.com/oss/202203/21/f7f83289195bc83d1be393d85e20885340b3df.png)

### PC Register

JVM中的程序计数寄存器(Program Counter Register)是对物理PC寄存器的一种抽象模拟，可以看作是当前线程所执行的字节码的行号指示器。

### JVM Stack

Java虚拟机栈，早期也叫Java栈。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame)，对应着一次次Java方法调用。它是线程私有的，同时生命周期也和线程一致。

**Stack Layout**：

虚拟机栈用于保存方法的局部变量、部分结果，并参与方法的调用和返回。它只涉及两个操作，每个方法执行时入栈，方法执行结束或抛出异常时出栈。因此，在任意一个时间点上，当前正在执行的方法都在栈顶栈帧，该栈帧也成为当前栈帧，其对应方法就当前方法。比如，一个嵌套调用函数的栈帧分布如下。

![multple stack frame layout](https://pdai.tech/images/jvm/jvm/0082zybply1gc8tjehg8bj318m0lbtbu.jpg)

可见，栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。而其中的大部分信息都能在Class文件的方法表中找到对应的静态对照物。

**Local Variable Table**：

局部变量表(Local Variable Table)是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。当一个方法被调用时，它的参数和局部变量会被顺次复制到表中。一般来说，局部变量表所需要的容量大小是编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。此外，由于它是线程私有的，所以局部变量不存在线程安全问题。

局部变量表最基本的存储单元是变量槽(Slot)。JVM会为表中每个Slot都分配一个访问索引，通过这个索引即可快速访问变量和参数值。至于64位数据，则只需要使用第一个Slot索引即可。值得一提的是，栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。

**Operand Stack**:

操作数栈(Operand Stack)也常被称为操作栈，它是一个后入先出(Last In First Out，LIFO)栈。其主要作用就是保护计算过程的中间结果，同时作为计算过程中变量的临时存储空间，且调用方法的返回值也往往存储在调用者的操作栈中。而所谓JVM的解释引擎是基于栈的执行引擎就是指的就是操作数栈的出栈和入栈过程。比如，下图是局部变量表和操作数栈在计算减法时的变化。

![操作数栈减法](https://media.geeksforgeeks.org/wp-content/cdn-uploads/jvm.png)

此外，操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。其中，32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。

**Dynamic Linking**：

每个栈帧都包含一个指向方法区中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接(Dynamic Linking)。在Java中，方法调用不同于方法执行，它指的是确定被调用方法的版本。

由于Java在编译得到字节码文件中，不涉及到传统C++语言编译时的链接的步骤。因此，一切方法调用在Class文件里面存储的都是符号引用，而不是方法在实际运行时内存布局中的入口地址（直接引用）。也就是说，方法调用需要在类加载阶段，甚至到运行期才能确定目标方法的直接引用。其中，在类加载阶段或者第一次使用的时候就被确定的调用称为静态解析，而另外一部分在每一次运行期间才确定的就称为动态连接。

**Return Address**：

方法返回地址(Return Address)用于存放调用该方法的PC寄存器值。本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。

### Native Method Stack

**JNI**：

Java本地接口(Java Native Interface)是一种连接本地代码和Java代码的机制，它允许二者相互调用。其中，本地代码一般是C/C++编写的。它将本地代码编译成平台相关的共享链接库(Shared Library)加载进JVM中，从而支持互相调用。

**本地方法调用**：

类似虚拟机栈是用于管理Java方法的调用，而本地方法栈则是用于管理本地方法的调用。此外，并非所有JVM都实现了本地方法栈，因为《Java虚拟机规范》中没有明确规定本地方法栈的使用语言、实现方法和数据结构等。如果不打算支持本地方法，也就无需实现本地方法栈。至于当前最流行的Hotspot JVM，它则是直接将本地方法栈和虚拟机栈合二为一。

### Heap

对于Java应用程序来说，Java堆是虚拟机所管理的内存中最大的一块。它被所有线程共享，且在虚拟机启动时创建。而其唯一目的就是存放对象实例，并由垃圾回收器进行统一管理。目前最主流的HotSpot虚拟机中，堆基于经典分代设计而被分为新生代、老年代和元空间（JDK1.8之前称为永久代）三部分。其中，元空间也就是HotSpot的方法区实现，尽管在《Java虚拟机规范》被称为非堆(Non-Heap)，但它实际上只是一个逻辑概念。

《Java虚拟机规范》指出堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过 -Xmx和-Xms控制），如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出OutOfMemoryError异常。

**对象的生命周期**：

在JVM内存模型的堆中，堆被划分为新生代和老年代。而新生代又被进一步划分为Eden区和Survivor区。其中，Survivor区由From Survivor和To Survivor组成。

当创建一个对象时，对象会被优先分配到新生代的Eden区。当Eden空间不足时，JVM将执行新生代的垃圾回收(Minor GC)。JVM 会把存活的对象转移到Survivor区中，并且对象年龄+1。此后，对象在Survivor区中同样也会经历Minor GC，每经历一次Minor GC，对象年龄都会+1如果分配的对象超过了设置的阈值，对象会直接被分配到老年代。

当老年代内存不足时，就会触发Major GC，进行老年区的内存清理。若老年去执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常。

**TLAB**:

为了提高对象分配的效率和线程安全性，JVM引入了TLAB(Thread Local Allocation Buffer)。TLAB是每个线程在堆中预先分配的一块私有内存区域，用于对象实例的创建。当线程需要创建对象时，它首先尝试在自己的TLAB中分配内存。这样可以避免在多线程环境下对堆的直接竞争，从而减少加锁和同步的开销。

虽然不是所有对象实例都能在TLAB中分配，但TLAB确实提高了并发环境下的内存分配速度。当TLAB空间不足时，线程会请求从Eden区分配更多内存，如果Eden区也满了，就会触发Minor GC。

### Method Area

方法区(Method Area)与堆一样，是各个线程共享的内存区域。它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但它却有一个别名非堆(Non-Heap)，目的是与Java堆区分开来。

方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误。

**方法区 vs 永久代 vs 元空间**：

方法区只是JVM规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而永久代(PermGen)是Hotspot虚拟机特有的概念，Java8的时候又被元空间(Metaspace)取代了，永久代和元空间都可以理解为方法区的落地实现。永久代物理是堆的一部分，和新生代、老年代地址是连续的，且受垃圾回收器管理；而元空间存在于堆外内存，不受垃圾回收器管理。

**JDK1.8 方法区变化**：

对于方法区，Java 8之后的变化包括：

- 移除了永久代，替换为元空间；
- 永久代中的class metadata转移到了堆外内存，不受JVM管理；
- 永久代中的interned Strings和class static variables转移到了Heap；
- 永久代参数(PermSize MaxPermSize)->元空间参数(MetaspaceSize MaxMetaspaceSize)。

### Runtime Constant Pool

运行时常量池(Runtime Constant Pool)是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表(Constant Pool Table)，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是String.intern()方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

## Java Class File

了解Java编译流程可知，Java程序并非类似C++的编译型语言，而是一种半编译语言。它会先将源程序编译成字节码文件(ByteCode File)也即Class文件，再交由JVM执行。可见，Java实现平台无关性的基础就是JVM和字节码存储格式。JVM不与包括Java语言在内的任何程序语言绑定，它只与Class文件这种特定的二进制文件格式所关联，而Class文件中则包含了JVM指令集、符号表以及若干其他辅助信息。值得一提的是，如果一个Java源文件中有多个类，那么编译后会生成除内部类之外的每个类对应的Class文件。

### Class File Structure

**Magic Number**：

每个Class文件的头4个字节被称为魔数(Magic Number)，它的唯一作用就是标识文件是否是一个Java字节码文件。

**Version**：

紧接着魔数的4个字节存储的是Class文件的版本号(Version)。

**Constant Pool**：

版本号之后是常量池，它存储各种常量，如字符串、类名、方法名、字段名等。

**Access Flags**：

访问标志标识类或接口的访问权限和特性。

**This Class**：

类索引指向常量池中的类或接口全名。

**Super Class**：

父类索引如果类不是接口，指向父类的全名。

**Interfaces**：

接口索引集合如果类是接口，列出实现的接口。

**Fields**：

字段表集合类或接口的字段信息。

**Methods**：

方法表集合类或接口的方法信息。

**Attributes**:

属性表集合：类、字段或方法的额外信息，如注解、源文件名等。

### ByteCode Instruction

## Class Loading Mechanism

JVM把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。

与那些在编译时需要进行连接的语言不同，在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让Java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为Java应用提供了极高的扩展性和灵活性，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。例如，编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类，用户可以通过Java预置的或自定义类加载器，让某个本地的应用程序在运行时从网络或其他地方上加载一个二进制流作为其程序代码的一部分。

**类生命周期**：

一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。上述7个阶段发生顺序如图所示。

![类生命周期](https://pdai.tech/images/jvm/java_jvm_classload_2.png)

**加载和初始化的时机**：

关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，《Java虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行初始化：
1）遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：

·使用new关键字实例化对象的时候。
·读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）
的时候。
·调用一个类型的静态方法的时候。

### Class Loading Process

在加载阶段，Java虚拟机需要完成以下三件事情：
1）通过一个类的全限定名来获取定义此类的二进制字节流。
2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

### Class Loader

## GC

垃圾回收(Garbage Collection)并非Java语言的伴生物。它的历史远比Java久远，诞生于1960年的Lisp是第一门使用内存动态分配和垃圾回收技术的语言。其主要关注三件事：

- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？

尽管当前内存分配和垃圾回收技术已经相当自动化，但我们仍需了解其背后原理，尤其是当需要排查各种内存溢出和泄漏的问题，或者当垃圾收集成为系统达到更高并发量瓶颈时，Java开发者们必须对这些自动化的技术实施必要的监控和调节。

**哪些内存需要回收**：

在JVM中，内存回收主要发生在堆区和方法区。但是《Java虚拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，方法区垃圾收集的性价比通常也是比较低的：在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回收成果往往远低于此。但是对于大量使用反射和动态代理等特性的场景，方法区回收就会非常必要了。因为这些技术都会导致方法区中的类急速膨胀。

方法区的内存回收主要是针对无用的类和废弃常量的回收。比如，一个字符串“java”曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类、接口、方法、字段的符号引用也与此类似。

和常量卸载相比，类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载:

- 该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。
- 加载该类的ClassLoader已经被回收。
- 该类对应的Class对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

此外，需要注意的是，JVM中还有其他区域也会发生内存回收，例如栈区（Stack）和本地方法栈（Native Method Stack），但这些区域的内存回收是由线程私有的，不需要垃圾收集器来处理。

至于**什么时候回收**和**如何回收**，则由GC算法规定。

### Marking

**引用计算法(Reference Counting)**：

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。

**可达性分析算法(Reachability Analysis)**：

可达性分析算法的基本思路就是通过一系列称为GC Roots的根对象作为起始节点集，从这些节点开始根据引用关系向下搜索（搜索走过的路径称为引用链），如果某个对象到CG Roots间没有任何引用链相连，则证明此对象是不能再被使用的。

在Java中，固定可作为GC Roots的对象包括以下几种：

- 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
- 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
- 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
- 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
- 所有被同步锁（synchronized关键字）持有的对象。
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

### Reference

无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。Java具有四种强度不同的引用类型。

**强引用**：被强引用关联的对象不会被回收。使用new一个新对象的方式来创建强引用。

**软引用**：被软引用关联的对象只有在内存不够的情况下才会被回收。使用SoftReference类创建软引用。

**弱引用**：被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生前。

**虚引用**：又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。使用 PhantomReference 来实现虚引用。

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
WeakReference<Object> wf = new WeakReference<Object>(obj);
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
```

### GC Algorithm

**分代收集理论**：

现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。一般将堆分为新生代和老年代。

- 新生代使用: 标记-复制算法
- 老年代使用: 标记-清除或者标记-整理算法

**标记-清除算法**：

最早出现也是最基础的垃圾收集算法是标记-清除(Mark-Sweep)算法，在1960年由Lisp之父John McCarthy所提出。如它的名字一样，该算法分为标记和清除两个阶段：它首先标记出所有需要回收的对象，标记完成后统一回收掉所有被标记的对象。

之所以说它是最基础的收集算法，是因为后续大多算法都以其为基础，改进其缺点而得到的。它的缺点主要有两个：

- 一是执行效率不稳定，如果Java堆中包含大量需要被清除的对象，这是就需要大量的标记和清除动作，导致整个算法执行效率都随对象变多而降低；
- 二是内存空间碎片化。标记和清除之后会产生大量的内存碎片，空间碎片太多可能会导致后续无法找到足够大的连续内存而不得不提前触发另一次垃圾收集动作。

**标记-复制算法**：

为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，1969年Fenichel提出了一种半区复制的垃圾回收算法。它将可用内存按容量分为大小相等的两块，每次只使用其中一块。当这一块用完了，就将还存活的内存复制到另一块上，然后清理掉当前内存块。这样子实现简单，运行高效。不过其缺陷也显而易见，就是将可用内存缩小为原来的一半。

现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。

HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。

**标记-整理算法**：

标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更重要的是，如果不想浪费50%空间，就需要额外的空间，所以老年代一般不采用这种算法。

针对老年代对象的存亡特征，1974年Edward Lueders提出了标记-整理算法。它标记过程和标记-清除算法一样，但后续步骤不是直接对可回收对象进行整理，而是让所有存活的对象都向内存空间一侧移动，然后直接清理掉边界之外的内存。

事实上，是否移动对象都存在弊端。移动内存时，若存活率过高，则开销会大大增大；而不移动内存时，要么需要忍受内存碎片的问题，要么需要有人如空闲内存链表这一类的解决方案。因此，一般的做法就是让虚拟机在多数时间使用标记-清除算法，暂时容忍内存碎片的问题，直到内存空间碎片化程度大到影响对象分配时，再采用标记-整理算法，以获得规整的内存。

### Garbage Collector

**Serial收集器**：

Serial收集器是最基础、历史最悠久的收集器。它是一个单线程工作的收集器，它不仅只使用一个线程去完成收集工作，而且会在其工作时暂停其他所有工作线程。它在新生代采用标记-复制算法，而在老年代采用标记-整理算法。

尽管其“Stop The World”的特性会给用户带来恶劣的体验，但它也并非一无是处。但事实上，迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方，那就是简单而高效（与其他收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的；对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。

**ParNew收集器**：

ParNew收集器实质上是Serial收集器的多线程并行版本。ParNew收集器除了支持多线程并行收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是不少运行在服务端模式下的HotSpot虚拟机，尤其是JDK 7之前的遗留系统中首选的新生代收集器，其中有一个与功能、性能无关但其实很重要的原因是：除了Serial收集器外，目前只有它能与CMS收集器配合工作。

类似Serial收集器，它在新生代采用标记-复制算法，而在老年代采用标记-整理算法。

**Parallel Scanvenge收集器**：

Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。但它的特点是关注点是吞吐量。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。

**Serial Old收集器**：

Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。

**Parallel Old收集器**：

Parallel Scavenge收集器的老年代版本。使用多线程和标记-整理算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑Parallel Scavenge收集器和Parallel Old收集器。

**CMS收集器**：

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。CMS收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。

从名字中的Mark Sweep这两个词可以看出，CMS 收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- 初始标记：暂停所有的其他线程，并记录下直接与root相连的对象，速度很快。
- 并发标记：同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- 重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。
- 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

**G1收集器**：

# Java核心卷阅读笔记

- [Java核心卷阅读笔记](#java核心卷阅读笔记)
  - [第四章 对象与类](#第四章-对象与类)
    - [4.1 面向对象程序设计概述](#41-面向对象程序设计概述)
      - [4.1.1 类](#411-类)
      - [4.1.2 对象](#412-对象)
      - [4.1.3 识别类](#413-识别类)
      - [4.1.4 类之间的关系](#414-类之间的关系)
    - [4.2 使用预定义类](#42-使用预定义类)
      - [4.2.1 对象与对象变量](#421-对象与对象变量)
      - [4.2.2 Java类库中的LocalDate类](#422-java类库中的localdate类)
      - [4.2.3 更改器方法和访问器方法](#423-更改器方法和访问器方法)
    - [4.3 用户自定义类](#43-用户自定义类)
    - [4.4 静态字段和静态方法](#44-静态字段和静态方法)
      - [4.4.1 静态字段](#441-静态字段)
      - [4.4.2 静态常量](#442-静态常量)
      - [4.4.3 静态方法](#443-静态方法)
      - [4.4.4 工厂方法](#444-工厂方法)
      - [4.4.5 main方法](#445-main方法)
    - [4.5 方法参数](#45-方法参数)
    - [4.6 对象构造](#46-对象构造)
      - [4.6.1 重载](#461-重载)
      - [4.6.2 默认字段初始化](#462-默认字段初始化)
      - [4.6.3 无参数的构造器](#463-无参数的构造器)
      - [4.6.4 显式字段初始化](#464-显式字段初始化)
      - [4.6.5 参数名](#465-参数名)
      - [4.6.6 调用另一个构造器](#466-调用另一个构造器)
      - [4.6.7 初始化块](#467-初始化块)
    - [4.7 包](#47-包)
      - [4.7.1 包名](#471-包名)
      - [4.7.2 类的导入](#472-类的导入)
      - [4.7.3 静态导入](#473-静态导入)
      - [4.7.4 在包中增加类](#474-在包中增加类)
      - [4.7.5 包访问](#475-包访问)
      - [4.7.6 类路径](#476-类路径)
      - [4.7.7 设置类路径](#477-设置类路径)
    - [4.8 JAR文件](#48-jar文件)
      - [4.8.1 创建JAR文件](#481-创建jar文件)
      - [4.8.2 清单文件](#482-清单文件)
      - [4.8.3 可执行JAR文件](#483-可执行jar文件)
      - [4.8.4 多版本JAR文件](#484-多版本jar文件)
  - [第五章 继承](#第五章-继承)
    - [5.1 类、超类和子类](#51-类超类和子类)
      - [5.1.1 定义子类](#511-定义子类)
      - [5.1.2 覆盖方法](#512-覆盖方法)
      - [5.1.3 子类构造器](#513-子类构造器)
      - [5.1.4 继承层次](#514-继承层次)
      - [5.1.5 多态](#515-多态)
      - [5.1.6 理解方法调用](#516-理解方法调用)
      - [5.1.7 阻止继承：final类和方法](#517-阻止继承final类和方法)
      - [5.1.8 强制类型转换](#518-强制类型转换)
      - [5.1.9 抽象类](#519-抽象类)
      - [5.1.10 受保护访问](#5110-受保护访问)
    - [5.2 Object：所有类的超类](#52-object所有类的超类)
      - [5.2.1 Object类型的变量](#521-object类型的变量)
      - [5.2.2 equals方法](#522-equals方法)
      - [5.2.3 相等测试与继承](#523-相等测试与继承)
    - [5.3 范型数组列表](#53-范型数组列表)
      - [5.3.1 声明数组列表](#531-声明数组列表)
    - [5.4 对象包装器与自动装箱](#54-对象包装器与自动装箱)
    - [5.5 参数数量可变的方法](#55-参数数量可变的方法)
    - [5.6 枚举类](#56-枚举类)
      - [6.2.3 函数式接口](#623-函数式接口)
      - [6.2.4 方法引用](#624-方法引用)
      - [6.2.5 构造器引用](#625-构造器引用)
      - [6.2.6 变量作用域](#626-变量作用域)
      - [6.2.7 处理lambda表达式](#627-处理lambda表达式)
    - [6.3 内部类](#63-内部类)
      - [6.3.1 使用内部类访问对象状态](#631-使用内部类访问对象状态)
      - [6.3.2 内部类的特殊语法规则](#632-内部类的特殊语法规则)
      - [6.3.3 内部类是否有用、必要和安全](#633-内部类是否有用必要和安全)
    - [6.4 服务加载器](#64-服务加载器)
    - [6.5 代理](#65-代理)
  - [第七章 异常、断言和日志](#第七章-异常断言和日志)
    - [7.1 处理错误](#71-处理错误)
      - [7.1.1 异常分类](#711-异常分类)
      - [7.1.2 声明检查型异常](#712-声明检查型异常)
      - [7.1.3 如何抛出异常](#713-如何抛出异常)
      - [7.1.4 创建异常类](#714-创建异常类)
    - [7.2 捕获异常](#72-捕获异常)
      - [7.2.1 捕获异常](#721-捕获异常)
      - [7.2.2 捕获多个异常](#722-捕获多个异常)
      - [7.2.3再次抛出异常与异常链](#723再次抛出异常与异常链)
      - [7.2.4 finally子句](#724-finally子句)
      - [7.2.5 try-with-Resources语句](#725-try-with-resources语句)
    - [7.3 使用异常的技巧](#73-使用异常的技巧)
    - [7.4 使用断言](#74-使用断言)
      - [7.4.1 断言的概念](#741-断言的概念)
      - [7.4.2 启用和禁用断言](#742-启用和禁用断言)
    - [7.5 日志](#75-日志)
      - [7.5.1 基本日志](#751-基本日志)
      - [7.5.2 高级日志](#752-高级日志)
      - [7.5.4 本地化](#754-本地化)
      - [7.5.5 处理器](#755-处理器)
      - [7.5.6 过滤器](#756-过滤器)
  - [第八章 泛型程序设计](#第八章-泛型程序设计)
    - [8.1 为什么要使用泛型程序设计](#81-为什么要使用泛型程序设计)
    - [8.2 定义简单的泛型类](#82-定义简单的泛型类)
    - [8.3 泛型方法](#83-泛型方法)
    - [8.4 类型变量的限定](#84-类型变量的限定)
    - [8.5 泛型代码和虚拟机](#85-泛型代码和虚拟机)
      - [8.5.1 类型擦除](#851-类型擦除)
    - [8.6 限制与局限性](#86-限制与局限性)
    - [8.7 泛型类型的继承规则](#87-泛型类型的继承规则)
    - [8.8 通配符类型](#88-通配符类型)
      - [8.8.1 通配符的概念](#881-通配符的概念)
      - [8.8.2 通配符的超类限定](#882-通配符的超类限定)
      - [8.8.3 无限定通配符](#883-无限定通配符)
    - [8.9 反射和泛型](#89-反射和泛型)
  - [第九章 集合](#第九章-集合)
    - [9.1 Java集合框架](#91-java集合框架)
      - [9.1.2 Collection接口](#912-collection接口)
      - [9.1.3 迭代器](#913-迭代器)
    - [9.2 集合框架中的接口](#92-集合框架中的接口)
    - [9.3 具体集合](#93-具体集合)
      - [9.3.1 链表 LinkedList](#931-链表-linkedlist)
      - [9.3.2 数组列表 ArrayList](#932-数组列表-arraylist)
      - [9.3.3 散列集 HashSet](#933-散列集-hashset)
      - [9.3.4 树集 TreeSet](#934-树集-treeset)
      - [9.3.5 队列与双端队列 Queue\&Deque](#935-队列与双端队列-queuedeque)
      - [9.3.6 优先队列 PriorityQueue](#936-优先队列-priorityqueue)
    - [9.4 映射](#94-映射)
      - [9.4.1 基本映射操作](#941-基本映射操作)
      - [9.4.2 更新映射条目](#942-更新映射条目)
      - [9.4.3 映射视图](#943-映射视图)
    - [12.2 线程状态](#122-线程状态)
      - [12.2.1 新建线程](#1221-新建线程)
      - [12.2.2 可运行线程](#1222-可运行线程)
      - [12.2.3 阻塞和等待线程](#1223-阻塞和等待线程)
      - [12.2.4 终止线程](#1224-终止线程)
    - [12.3 线程属性](#123-线程属性)
    - [12.4 同步](#124-同步)
      - [12.4.3 锁对象](#1243-锁对象)
      - [12.4.4 条件对象](#1244-条件对象)
      - [12.4.5 synchronized关键字](#1245-synchronized关键字)

## 第四章 对象与类

### 4.1 面向对象程序设计概述

- 面向对象程序设计（object-oriented programming, OOP）是当今主流的程序设计范型

#### 4.1.1 类

- 类（class）是构造对象的**模板**或蓝图
- 由类**构造**（construct）对象的过程称为创建类的**实例**（instance）
- 对象中的数据称为**实例字段**（instance field），操作数据的过程称为**方法**（method）
- OOP的两个重要特性——**封装**和**继承**
  - 封装（encapsulation）指的是将数据和行为组合在一个包中，并对对象使用者隐藏具体实现的方式
    - 实现封装的关键在于，绝不能让类中方法直接访问其他类的实例字段，即：程序只能通过对象方法与对象数据进行交互
  - 继承（inheritance）指的是通过扩展一个类来建立另一个类的过程
    - 事实上，在Java中所有类都扩展来自==Object==类

#### 4.1.2 对象

- 对象的三个主要特性：
  - 对象的行为（behavior）
  - 对象的状态（state）
  - 对象的标识（identity）

#### 4.1.3 识别类

- 首先从识别类开始，然后再为各个类添加方法

#### 4.1.4 类之间的关系

- 依赖：一个类的方法使用或者操作另一个类的对象，则称这个类依赖与另一个类
- 聚会：一个类对象包含着另一个类对象
- 继承：

### 4.2 使用预定义类

#### 4.2.1 对象与对象变量

- 新建一个对象必须用new不能省略

- Java的对象变量类似C++的对象指针，而非C++中的引用
- 所有Java的对象都存储在堆中

#### 4.2.2 Java类库中的LocalDate类

#### 4.2.3 更改器方法和访问器方法

- 只访问对象而不修改对象的方法称为访问器方法
- 修改对象状态的方法称为更改器方法
- 注意：可以通过添加==@data==注解来避免为类中每个字段都添加get和set方法

### 4.3 用户自定义类

### 4.4 静态字段和静态方法

#### 4.4.1 静态字段

- 静态字段也被称为**类字段**

> 术语静态只是沿用了C++的叫法，并无实际意义

#### 4.4.2 静态常量

- 直接用类名访问，即：不需要实例化一个对象来访问

#### 4.4.3 静态方法

- 静态方法是不在对象上执行的方法（可以认为静态方法是一个没有this参数的方法）
- 使用静态方法访问本类成员时，只允许访问静态成员

> 术语“静态”有一段不寻常的历史。
>
> 起初，C语言引入关键字static是为表示退出一块后==依然存在局部变量和函数==。在这种情况下，术语“静态”是有意义的：变量一直保留，当再次进入该块时仍然存在。
>
> 随后，static在C语言中有了第二种含义，表示==不能从其他文件访问的全家变量和函数==。
>
> 最后，C++语言第三次重用类这个关键词，与前面赋予的含义完全无关，它指的是属于类而==不属于任何类对象==的变量和函数。（这里与java含义相同）

#### 4.4.4 工厂方法

- 静态方法还有一种常见的用途——使用静态**工程方法**来构造对象
  - 使用的原因：
    - 无法命名构造器
    - 使用构造器时，无法改变所构造对象的类型

#### 4.4.5 main方法

- main方法不对任何对戏进行操作。事实上，在程序启动时还没有任何对象。静态的main方法将执行并构造程序所需要的对象

<div align="right"><font size="4.5">7月23日</div>

### 4.5 方法参数

- Java语言==总是==采用**按值调用**，也就是说，方法得到的是所有参数的副本，也即：方法不能修改传递给它参数变量的任何内容

### 4.6 对象构造

#### 4.6.1 重载

- 如果多个方法有相同的名字、不同的参数，便称为**重载**

#### 4.6.2 默认字段初始化

- 如果在构造器中没有显式的为字段设置初值，那么就会自动地赋为默认值

#### 4.6.3 无参数的构造器

- 如果一个类没有编写构造器，那么编译器就会为你提供一个无参构造器；如果类中编写了至少一个构造器，但是没有提供无参数的构造器，那么构造对象时使用无参构造器就是不合法的，即：编译器不会为你提供一个无参构造器
- 无参构造器一般将所有的实例字段设置为默认值

#### 4.6.4 显式字段初始化

- 通过重载类的构造器方法，可以采用多种形式设置类的实例字段的初始状态
- 注意：Java中没有C++初始化列表的语法，即：所有赋值操作都得写到函数内部用等号去赋值

#### 4.6.5 参数名

- 类成员方法参数与实例字段同名时，参数变量会**遮蔽**同名实例字段，这个特点常常用在构造器中

  ``` java
  public Employee(String name, double salary) {
    this.name = name;
    this.salary = salary;
  }
  ```

- 注意：在C++中，经常用下划线作为实例字段的前缀，例如：name字段可能被命名为_name，但Java中不常这么做

#### 4.6.6 调用另一个构造器

- this关键字可以直接调用同一个类的另一个构造器

  ``` java
  public Employee(double s) {
    this("Emloyee" + id, s);
    id++;
  }
  ```

- 注意：尽管在Java中this引用等价于C++中的this指针，但是C++中不能在一个构造器中调用另一个构造器

#### 4.6.7 初始化块

- 除了在构造器中设置值和在声明中赋值两种初始化字段方法，还有初始化块第三种机制

### 4.7 包

#### 4.7.1 包名

- 使用包的目的是确保类名的唯一性
- 事实上，为了保证类名的绝对唯一性，要用一个因特网域名以逆序的形式作为包名
- 注意：从编译器的角度来看，嵌套的包之间没有任何关系

#### 4.7.2 类的导入

- 使用方法：
  - 完全限定名，即：包名后面跟着类名
  - import语句导入整个包
- 注意：
  - C++中include和Java中import并没有共同之处，因为C++完全无法避免不使用include，而Java则可以避免使用import
  - 实际上，在C++中和包机制类似的是命名空间（namespace）的特性，可以认为Java中import和package语句类似C++中namespace和using语句

#### 4.7.3 静态导入

- Java允许import语句导入静态方法和静态字段，而不只是类

  ``` java
  import static java.lang.System.out;
  ```

#### 4.7.4 在包中增加类

- 想要将类放入包中，就必须将包的名字放在源文件的开头，即：

  ``` java
  package com.xxx.xxx
  ```

  放在源文件开头

- 如果源文件开头没有放置package语句，那么这个源文件就属于无名包

- 注意：当包实际位置与package语句中不匹配时，编译能通过，但无法正确运行，因为虚拟机找不到类

#### 4.7.5 包访问

- 标记了public的部分可以由任意类使用；标记了private的部分只能由定义它们的类使用；如果没有指定public或private，这个部分可以被同一个包中所有方法访问

#### 4.7.6 类路径

#### 4.7.7 设置类路径

### 4.8 JAR文件

#### 4.8.1 创建JAR文件

- 使用jar命令

#### 4.8.2 清单文件

- 除了类文件、图像和其他资源，每个JAR文件还包含一个清单文件（manifest），用于描述归档文件的特殊特性

#### 4.8.3 可执行JAR文件

#### 4.8.4 多版本JAR文件

## 第五章 继承

### 5.1 类、超类和子类

#### 5.1.1 定义子类

- 注意：Java与C++定义继承的方式十分相似。Java用关键字extends代替了C++中的冒号；在Java中，所有的继承都是公共继承，而没有C++中的私有继承和保护继承
- 基类=超类，子类=派生类

#### 5.1.2 覆盖方法

- 用特殊关键字super访问超类方法
- 注意：super和this不是类似的概念，因为super并非一个对象的引用

#### 5.1.3 子类构造器

- 可以使用super调用超类构造器，方法类似this，但使用super调用构造器的语句必须是子类构造器的第一条语句

- 一个变量可以指示多种实际类型的现象称为**多态**（polymorphism）
- 在运行时能够自动地选择适当的方法，称为**动态绑定**（dynamic binding）

#### 5.1.4 继承层次

#### 5.1.5 多态

- 超类变量既可以引用一个它本身类型的对象，也可以引用它的任何子类的对象

#### 5.1.6 理解方法调用

- 编译器查看对象的声明类型和所有可用方法（子类方法和超类非私有方法，注意：子类方法会覆盖超类同名方法）
- 编译器确定方法调用中提供的参数类型
- 编译器选择一个与所提供参数类型完全匹配的方法（这个过程称为==重载解析==）
  - 如果是private方法、static方法 、final方法或者构造器，那么编译器可以准确知道应该调用哪个方法（这称为==静态绑定==）
  - 如果调用方法依赖于隐式参数的实际类型（即：this指针指向超类还是子类），那么必须在运行过程中使用==动态绑定==
    - 程序运行且采用动态绑定调用方法时，虚拟机必须调用与x引用对象实际类型的那个方法。假设x的类型是D，D类型又是C类型的子类。那么如果D类型中定义了方法f（Srting）就会调用这个方法；否则将在D的超类C中寻找f（String）

#### 5.1.7 阻止继承：final类和方法

- 如果在定义类的时候使用了final修饰符，那么这个类就是不允许扩展的
- 如果定义类中某个方法时使用final修饰符，那么这个方法就不能被子类覆盖

#### 5.1.8 强制类型转换

- 只能在继承层次内进行强制
- 在将超类强制转换称子类前，应该使用instanceof进行检查

#### 5.1.9 抽象类

- 包含一个或多个抽象方法的类本身必须被声明为抽象类
- 使用**abstract**关键字
- 抽象类不能实例化
- 注意：在C++中，有一种抽象方法称为纯虚函数，如果==一个类至少包含一个纯虚函数，那么这个类就是抽象类==

#### 5.1.10 受保护访问

- 如果定义类中字段时使用了protected修饰符，那么这个字段就能被子类方法访问（子类也不能访问超类private字段）
- 在Java中，保护字段只能由同一个包中的类访问

### 5.2 Object：所有类的超类

- Object类是Java中所有类的始祖，在Java中每个类都扩展类Object，但并不需要明确写出extend Object

#### 5.2.1 Object类型的变量

- 在Java中，只有基本类型不是对象，例如：数值、字符和布尔类型

#### 5.2.2 equals方法

- Object类中的equals方法用于检测一个对象是否等于另外一个对象。

#### 5.2.3 相等测试与继承

<div align="right"><font size="4.5">7月26日</div>

### 5.3 范型数组列表

- ArrayList是一个有类型参数的泛型类

#### 5.3.1 声明数组列表

- ArrayList类似于C++的vector数组，但C++是按值拷贝，赋值操作a=b会构造一个与b长度相同且元素相同的新向量，而在Java中，这条赋值语句只会让两者引用同一个数组列表

- ```java
  //新建空数组列表
  ArrayList<E>()
    
  //在数组列表末尾追加一个元素。永远返回true
  boolean add(E obj)
  
  //返回当前存储在数组列表的元素个数
  int size()
  
  ```

#### 5.3.2 访问数组列表元素

- ``` java
  //将值obj放置在数组列表的指定索引位置，返回之前内容
  E set(int index, E obj)
    
  //得到指定索引位置存储的值
  E get(int index)
    
  //后移元素从而将obj插入指定索引位置
  void add(int index, E obj)
   
  //删除指定索引位置元素，并将后面的所有元素前移，返回所删除的元素 
  void remove(int index)
  ```

### 5.4 对象包装器与自动装箱

- 所有的基本类型都有一个与之对应的类。通常，这些类被称为**==包装器==**
  - Intger、Long、Float、Double、Short、Byte、Character和Boolean
- 包装器是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值
- 包装器类是final，因此不能派生它们的子类
- List.add(3)将自动地变化成List.add(Intger.valueOf(3))，这种变化被称为==自动装箱==

### 5.5 参数数量可变的方法

### 5.6 枚举类

- ``` java
  //返回指定类中指定名字的枚举常量
  static Enum valueOf(Class enumClass, String name)
  
  //返回枚举常量
  String toString()
  
  //返回枚举常量在enum声明中的位置，位置从0开始计数
  int ordinal()
  
  //返回枚举常量与other的次序差
  int compareTo(E other)
  ```

### 5.7 反射

- 能够分析类能力的程序称为反射（reflective）
- 反射机制的功能
  - 在运行时分析类
  - 在运行时检查对象
  - 实现泛型数组操作代码
  - 利用Method对象（这个对象类似C++函数指针）

#### 5.7.1 Class 类

- 在程序运行期间，Java运行时系统会为所有对象维护一个运行时类型标识，保存这些信息的类名为Class
- 获得Class类对象的方法：
  - Object类中的getClass方法将会返回一个Class类型的实例
  - 使用静态方法forName获得类名对应的Class对象
  - 如果T是任意的Java类型，T.class

#### 5.7.2 声明异常入门

- 抛出异常要比终止程序灵活得多，这是因为可以提供一个处理器（handler）捕获这个异常并进行处理
- 异常类型：
  - 非检查型
  - 检查型：对于检查型异常，编译器将会检查程序员是否知道这个异常并做好准备来处理后果
    - 如果一个方法包含一条可能抛出检查型异常多语句，则在方法名上增加一个throws子句
    - 调用这个方法的任何方法也需要一个throws声明

#### 5.7.4 利用反射分析类的能力

#### 5.7.5 使用反射在运行时分析对象

## 第六章 接口、lambda表达式与内容

### 6.1 接口

#### 6.1.1 接口的概念

- 接口中所有方法都自动是public方法
- 接口中不会存在实例字段
- 一个类可以实现一个或多个接口，使用关键词implements

#### 6.1.2 接口的属性

- 接口不算类，也即：不能使用new实例化一个接口

- 虽然接口中不能包含实例字段，但可以包含常量
- 接口中字段总是public static final

#### 6.1.3 接口与抽象类

#### 6.1.4 静态和私用方法

#### 6.1.5 默认方法

- 可以为接口中的方法提供一个默认实现，必须使用defaul关键词修饰

#### 6.1.6 解决默认方法冲突

- 超类优先，如果超类（接口超类只能是接口）提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略
- 接口冲突，如果一个接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型相同的方法，必须覆盖这个方法来解决冲突

#### 6.1.7 接口与回调

- 回调（callback）是一种常见的程序设计模式，在这种模式下，可以指定某个特定事件发生时应该采取的动作

#### 6.1.8 Comparator接口

#### 6.1.9 对象克隆

- 浅拷贝
- 深拷贝

### 6.2 lambda表达式

#### 6.2.1 为什么引入lambda表达式

- Java是一种面向对象语言，传递代码必须构造一个对象，而这个对象的类需要有一个方法包含所需的代码

#### 6.2.2 lambda表达式的语法

- lambda表达式的一种形式：参数，箭头以及一个表达式

```java
(String first, String second) -> {
  return first < second;
}
```

#### 6.2.3 函数式接口

- 在Java中，lambda表达式可以转换成接口

#### 6.2.4 方法引用

- 方法引用（method reference）能指示编译器生成一个函数式接口的实例，覆盖这个接口的抽象方法来调用给定的方法

#### 6.2.5 构造器引用

- 构造器引用与方法引用类似，只不过方法名为new

#### 6.2.6 变量作用域

- lambda表达式通常有三个部分：一个代码块、参数和自由变量的值
  - 其中，自由变量的值是指非参数而且不在代码中定义的变量，也称变量被lambda表达式捕获了

#### 6.2.7 处理lambda表达式

- 使用lambda表达式的原因——延迟执行：
  - 在一个单独的线程中运行代码
  - 多次运行代码
  - 在算法的适当位置运行代码
  - 发生某种情况时，才运行代码
  - 只在有必要时才运行代码

<div align="right"><font size="4.5">7月27日</div>

### 6.3 内部类

- 内部类是定义在另一个类中的类
- 使用内部类的原因：
  - 内部类可以对同一个包中其他类进行隐藏
  - 内部方法可以访问定义这个类的作用域中的数据，包括原本的私有数据

#### 6.3.1 使用内部类访问对象状态

- 一个内部类方法可以访问自己的数据字段，也可以访问创建它的外围类对象的数据字段

#### 6.3.2 内部类的特殊语法规则

#### 6.3.3 内部类是否有用、必要和安全

- 内部类是一个编译器现象与虚拟机无关

### 6.4 服务加载器

### 6.5 代理

- 利用代理（proxy）可以在运行时创建实现了一组给定接口的新类

## 第七章 异常、断言和日志

- 对于异常情况，Java使用类一种称为异常处理的错误捕获机制（与C++异常处理机制类似）

- 在Java语言中给出了3种处理系统错误的机制：
  - 抛出一个错误
  - 日志
  - 使用断言

### 7.1 处理错误

- 如果由于出现错误而使得某些操作没有完成，程序应该
  - 返回到一种安全状态，并且能够让用户执行其他命令；或者
  - 允许用户保存所有工作的结果，并以妥善的方式终止程序

#### 7.1.1 异常分类

- 所有异常都是由Throwable继承而来，但在下一层立即分解为两个分支：Error和Exception：
  - Error类层次描述了Java运行时系统内部错误和资源耗尽错误
    - 如果出现了这种错误，除了通知用户，并且尽力妥善地终止程序之外，程序员几乎无能为力
  - Exception类又分为两支：一支派生与RuntimeException；另一支包含其他异常
    - “如果出现RuntimeException异常，那么一定是你的问题”
- Java语言将派生与Error类或RuntimeException类的所有异常称为**非检查类型**，所有其他的异常称为**检查型异常**

#### 7.1.2 声明检查型异常

- 方法不仅要告诉编译器将要返回什么值，还要告诉编译器有可能发生什么错误

#### 7.1.3 如何抛出异常

#### 7.1.4 创建异常类

- 定义一个派生于Exception的类或Exception子类的类

### 7.2 捕获异常

#### 7.2.1 捕获异常

- 如果程序某个地方发生了异常，但没有任何地方捕获这个异常，程序就会终止，并在控制台上打印一个消息，其中包括这个异常的类型和一个堆栈轨迹
- 想要捕获一个异常，需要设置try/catch语句块
  - 如果try语句块中任何代码块抛出了catch子句中指定的一个异常类，那么
    - 程序将跳过try语句剩余代码
    - 程序将执行catch子句中处理器代码
  - 如果try语句块中的代码没有抛出任何异常，那么程序将跳过catch子句

#### 7.2.2 捕获多个异常

- 在一个try语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理，要为每个异常类型使用一个单独的catch子句

#### 7.2.3再次抛出异常与异常链

- 可以在catch语句中抛出一个异常（希望改变异常类型时会这样做）

#### 7.2.4 finally子句

- finally子句通常用于释放try代码块中获取的资源，因为当try中某条代码发生异常时，跳转到catch语句块再清理会十分繁琐

- 无论try语句发生异常与否，finally子句都会执行

#### 7.2.5 try-with-Resources语句

### 7.3 使用异常的技巧

### 7.4 使用断言

- 在一个具有自我保护能力的程序中，断言很常用

#### 7.4.1 断言的概念

- 断言机制允许在测试期间向代码插入一些检查，而在生产代码中会自动删除这些检查
- Java语言引入了关键词assert
  - assert condition
  - assert condition ： expression

#### 7.4.2 启用和禁用断言

- 在默认情况下，断言是禁用的
- 启用或禁用断言是类加载器（class loader）的功能

### 7.5 日志

- 日志的优点：
  - 可以很容易地取消全部日志记录，或者仅仅取消某个级别以下的日志，而且可以很容易地再次打开日志开关
  - 可以简单地禁止日志记录，因此，将这些日志代码留在程序中的开销很小
  - 日志记录可以被定向到不同的处理器
  - 日志记录器和处理器都可以对记录进行过滤
  - 日志记录可以采用不同的方式格式化，例如，纯文本或XML

#### 7.5.1 基本日志

- 要想生成简单的日志记录，可以使用全局日志记录器并调用其info方法

#### 7.5.2 高级日志

#### 7.5.4 本地化

#### 7.5.5 处理器

#### 7.5.6 过滤器

## 第八章 泛型程序设计

### 8.1 为什么要使用泛型程序设计

- 泛型程序设计（generic programming）意味着编写的代码可以对多种不同类型的对象重用

<div align="right"><font size="4.5">7月28日</div>

### 8.2 定义简单的泛型类

- 泛型类（generic class）就是有一个或多个类型变量的类
- 泛型类的定义中，会引入一个类型变量T，用简括号（<>）括起来，放在类后面
  - 常见的做法是类型变量使用大写字母
    - E表示集合的元素类型
    - K和V分别表示键和值的类型
    - T表示任意类型
  - 注意：表面上看，Java的泛型类类似于C++的模版类。唯一的明显区别是Java没有特殊的template关键字。但是，这两个机制实际上有本质的区别

### 8.3 泛型方法

- 泛型方法可以在普通类中定义也可以在泛型类中定义

### 8.4 类型变量的限定

- 可以对类型变量设置一个**限定**（bound）来限制类型变量的取值，具体方法:

  ```java
  <T extends BoundingType>
  ```

  表示T应该是限定类型（BoundingType）的子类型，限定类型即可以是类也可以是接口

- 注意：C++中不能对模板类参数的类型加以限制

### 8.5 泛型代码和虚拟机

- 虚拟机中没有泛型类对象——所有对象属于普通类

#### 8.5.1 类型擦除

- 无论何时定义一个泛型类型，都会自动提供一个相应的原始类型，即：去掉类型名参数后的泛型类型名

- 注意：就这点而言，Java的泛型和C++的模板就有很大区别，C++会为模板的每个实例化产生不同的类型，这一现象被称为“模板代码膨胀”

### 8.6 限制与局限性

- 不能用基本类型实例化类型参数
- 运行时类型查询只使用于原始类型
- 不能创建参数化类型的数组
- 不能实例化类型参数
- 不能构造泛型数组

### 8.7 泛型类型的继承规则

- 无论S和T有什么关系，通常泛型\<S\>和泛型\<T\>都没有任何关系

### 8.8 通配符类型

#### 8.8.1 通配符的概念

- 在通配符类型中，允许类型参数发生变化，例如：Pair\<? extends Employee\>表示任何泛型Pair类型，它的类型参数是Employee的子类

#### 8.8.2 通配符的超类限定

- 通配符限定与类型限定十分类似，但它还可以指定一个超类型限定，例如： ？ Super Manager，表示这个通配符限制为Manager的超类型

#### 8.8.3 无限定通配符

### 8.9 反射和泛型

## 第九章 集合

### 9.1 Java集合框架

#### 9.1.2 Collection接口

- 在Java类库中，集合类的基本接口是Collection接口

  - 其中提供两个基本方法

    - ```java
      //向集合添加元素，如果改变了集合返回true；否则返回false
      boolean add(E element);
      ```

    - ``` java
      //返回一个实现了Iterator接口的对象
      Iterator<E> iterato();
      ```

#### 9.1.3 迭代器

- Java集合类库中的迭代器和C++模板库中迭代器的概念有重大区别

<div align="right"><font size="4.5">7月29日</div>

### 9.2 集合框架中的接口

- Collection（集合）和Map（映射）并列
  - 继承自Collection：List（有序数组）、Set（数学意义上的集合）和Queue（队列）并列

### 9.3 具体集合

#### 9.3.1 链表 LinkedList



#### 9.3.2 数组列表 ArrayList

- 通过迭代器访问元素
- 通过get和set访问元素

#### 9.3.3 散列集 HashSet

- 散列表为每个对象计算一个整数，称为散列码（hash code）
- 在Java中，散列表用链表数组实现，每个链表被称为桶
- 无法控制元素出现的顺序，但能够快速查找元素

#### 9.3.4 树集 TreeSet

- 树集与散列集十分类似，但树集是用一个树数据结构完成的（红黑树）
- 能够控制元素出现的顺序，且能够快速查找元素
- 与散列表相比，元素添加树集更慢，但检查重复元素树集更快

#### 9.3.5 队列与双端队列 Queue&Deque

- 队列允许高效地在尾部添加元素并在头部删除
- 双端队列允许在头部和尾部都高效地删除或添加元素

#### 9.3.6 优先队列 PriorityQueue

- 优先队列中的元素可以按照任意顺序插入，但会按照有序的顺序进行检索，也即：无论何时调用remove函数总会获得当前优先队列中的最小元素

### 9.4 映射

- 映射用来存放键/值对
- 提供了键值，就能够查找到值

#### 9.4.1 基本映射操作

- Java类库为映射提供了两个通用的实现：HashMap和TreeMap，两个类都实现了Map接口
- 与集合一样，散列映射稍快一些，如果不需要按照有序的顺序访问键，最好选择散列映射

#### 9.4.2 更新映射条目

- 当键第一次出现时：
  - getOrDefault
  - putIfAbsent
  - merge

#### 9.4.3 映射视图

- 映射不是集合，但可以获取映射的视图——实现了Collection接口或者某个字接口的对象

- 有三种视图：键集、值集合以及键/值对集合

- ```java
  //返回Map.Entry对象的一个集视图。可以从这个集合中删除元素，它们将从映射中删除，但不能添加任何元素
  Set<Map.Entry<K, V>> entrySet()
  
  //返回映射中所有键的一个集视图。可以从这个集中删除元素，键和相关联的值将从映射中删除，但不能添加任何元素
  Set<K> keySet()
    
  //返回映射中所有值的一个集合视图。可以从这个集合中删除元素，所删除的值及相应的键将从映射中删除，不过不能添加任何元素
  Collection values()
  ```

#### 9.4.4 弱散列映射 WeakHashMap

- 使用WeakHashMap，当对键唯一引用来自散列表映射条目时，这个数据结构将与垃圾回收协作器协同工作一起删除键/值对

#### 9.4.5 链接散列集与映射 LinkedHashSet&LinkedHashMap

- LinkedHashSet和LinkedHashMap类会记住插入元素项的顺序

#### 9.4.6 枚举集与映射 EnumSet&EnumMap

### 9.5 视图与包装器

- 视图：初看起来，视图似乎仅仅是为映射创建了一个集合，但事实并非如此，视图实际上可以操纵原映射

### 9.6 算法

## 第十二章 并发

### 12.1 什么是线程

- ``` java
  //构造一个新线程，调用指定目标的run方法
  Thread(Runable target)
    
  //启动这个线程，从而调用run方法，这个方法会立即返回
  void start()
    
  //休眠指定的毫秒数
  static void sleep(long millis)
  ```

### 12.2 线程状态

- 线程可能有以下六种状态：
  - New（新建）
  - Runable（可运行）
  - Blocked（阻塞）
  - Waiting（等待）
  - Time waiting（计时等待）
  - Terminated（终止）

#### 12.2.1 新建线程

- 当用new操作符创建一个新线程时，这个线程还没有开始运行，即线程处于新建状态

#### 12.2.2 可运行线程

- 一旦调用start方法，线程就处于可执行状态
- 处于可执行的线程可能正在运行也可能没有运行

#### 12.2.3 阻塞和等待线程

- 当线程处于阻塞或等待状态时，它暂时是不活动的

#### 12.2.4 终止线程

- 线程会由于以下两个原因终止：

  - run方法正常退出，线程自然终止
  - 因为一个没有捕获的异常终止了run方法，使线程意外终止

- ```java
  //等待终止指定的线程
  void join()
    
  //等待指定的线程终止或等待经过指定的毫秒数  
  void join(long millis)
  ```

### 12.3 线程属性

### 12.4 同步

- 竞态条件

#### 12.4.3 锁对象

- ReenTrantLock类
- 重入锁：线程可以反复获得已拥有的锁
- 锁有一个持有计数（hold count）来跟踪对lock方法对嵌套调用，线程每调用一次lock后都要调用一次unlock来释放锁。由于这个特性，被一个锁保护的代码可以调用另一个使用相同锁的方法

#### 12.4.4 条件对象

- 可以使用条件对象类管理那些已经获得了一个锁却不能做有用工作的线程

#### 12.4.5 synchronized关键字

- 锁与条件对象的总结
  - 锁用来保护代码片段，一次只能有一个线程执行被保护的代码
  - 锁可以管理试图进入被保护代码段的线程
  - 一个锁可以有一个或多个相关联的条件对象
  - 每个条件对象管理那些已经进入被保护代码但还不能运行的线程
- Java每个对象都有一个内部锁，如果一个方法声明时有synchronized关键字，那么对象的锁将保护整个方法，也即：要使用这个方法必须获得内部对象锁

# Lex && Yacc

## Lex

### 概述

Lex是一种工具，它支持正则表达式来描述各个词法单元的模式，由此给出一个词法分析器的规约。
Lex工具的输入表示方法被成为Lex语言，而工具本身则称为Lex编译器。

### 结构

一个Lex程序通常具有如下形式：

``` txt

声明部分

%%

转换规则

%%

辅助函数

```

### 语法

Lex 程序的每个规则转换具有如下形式：模式{动作}
每个模式是一个正则表达式，它可以使用声明部分给出的正则定义；动作部分则是代码片段。


声明部分有时会出现一对特殊的符号：%{和%}。出现在括号内部的所有内容都直接被复制到文件lex.yy.c中。它们不会被当作正则定义处理

和出现在%{……%}中的声明部分一样，出现在辅助函数中的所有内容都被直接复制到lex.yy.c中

## Yacc

> Yacc 表示“yet another compiler-compiler”，即又一个编译器的编译器。

### 结构

``` txt

声明
%%

翻译规则

%%
辅助性C语言例程
```

声明部分一般包括两块内容：

+ 用%{和%}括起来的C语言声明

+ 第二或第三部分中翻译规则及过程中使用的临时变量声明

规则部分包括多个规则。

每个规则由一个文法产生式和一个相关联的语义动作组成。

``` txt
例如，以下规则：

<产生式头>: <产生式体1> | <产生式体2> | …… | <产生式体n>

在Yacc中应该写成：

<产生式头>: <产生式体1> { <语义动作1> }
		  | <产生式体2> { <语义动作2> }
						…… 
		  | <产生式体n> { <语义动作n> }
		  ;
```

### 语法

+ 在一个Yacc产生式中，如果一个由字母和数位组成的字符串没有加引号且为被声明为词法单元，它就会被当作非终结符号处理。

+ 不同的产生式体用竖线分开，每个产生式头以及它可选的产生式体及语义动作之后跟一个分号

+ 在语义动作中，符号$$表示和相应产生式头的非终结符号关联的属性值，而$i表示和相应产生式体中第i个文法符号关联的属性值
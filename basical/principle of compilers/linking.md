# 链接

- [链接](#链接)
  - [目标文件](#目标文件)
    - [可重定位目标文件](#可重定位目标文件)
    - [可执行目标文件](#可执行目标文件)
  - [符号和符号表](#符号和符号表)
  - [符号解析](#符号解析)
    - [链接静态库](#链接静态库)
  - [重定位](#重定位)
  - [参考](#参考)

`链接（linking）`是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。

链接器的存在使得`分离编译（separate compilation）`成为可能，即：我们不用再将一个应用程序组织成一个巨大的源文件，而是可以将它们分解成更好管理的小模块，可以独立地修改和编译这些模块。

根据链接执行时间的不同，可将链接分为三类：

- 静态链接（Static Linking）：静态链接是在编译时将所有需要的代码和库文件链接成一个单独的可执行文件，程序运行时不再需要额外的依赖文件。静态链接可以提高程序的运行效率和稳定性，但是会导致程序体积增大，不利于程序的更新和维护。

- 动态链接（Dynamic Linking）：动态链接是在程序运行时将需要的代码和库文件链接成一个单独的可执行文件，程序运行时需要依赖动态链接库文件。动态链接可以减小程序体积，便于程序的更新和维护，但是会增加程序运行时的开销。

- 装载时链接（Load-time Linking）：装载时链接是在程序运行时将需要的代码和库文件链接成一个单独的可执行文件，但是不同于动态链接，装载时链接库文件是在程序加载到内存时进行的。装载时链接可以减小程序体积，但是会增加程序加载时间，并且不同的操作系统和平台可能具有不同的实现方式。

为了构造可执行文件，链接器必须完成两个主要任务：

- 符号解析（symbol resolution）。目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量（即 C 语言中任何以 static 属性声明的变量）。符号解析的目的是将每个符号引用正好和一个符号定义关联起来。
- 重定位（relocation）。编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条目（relocation entry）的详细指令，不加甄别地执行这样的重定位。

## 目标文件

目标文件有三种形式：

- 可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。
- 可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存并执行。
- 共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。

一般来说，编译器和汇编器生成可重定位目标文件（包括共享目标文件）；而链接器则可生成可执行目标文件。

### 可重定位目标文件

`ELF(Executable and Linkable Format)`文件

### 可执行目标文件

## 符号和符号表

每个可重定位目标模块 m 都有一个符号表，它包含 m 定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号：

- 由模块 m 定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的 C 函数和全局变量。
- 由其他模块定义并被模块 m 引用的全局符号。这些符号称为外部符号，对应于在其他模块中定义的非静态 C 函数和全局变量。
- 只被模块 m 定义和引用的局部符号。它们对应于带 static 属性的 C 函数和全局变量。这些符号在模块 m 中任何位置都可见，但是不能被其他模块引用。

## 符号解析

### 链接静态库

## 重定位

## 参考

[深入理解计算机系统-第7章 链接](https://hansimov.gitbook.io/csapp/part2/ch07-linking)

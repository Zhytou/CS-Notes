# 并发模型

- [并发模型](#并发模型)
  - [进程 Process](#进程-process)
    - [进程API Process API](#进程api-process-api)
    - [进程的地址空间 Process Address Space](#进程的地址空间-process-address-space)
    - [进程间通信 IPC](#进程间通信-ipc)
    - [进程调度 Process Scheduling](#进程调度-process-scheduling)
  - [线程 Thread](#线程-thread)
    - [POSIX线程API](#posix线程api)
    - [线程同步](#线程同步)
  - [协程 Coroutine](#协程-coroutine)
  - [基于事件的并发模型](#基于事件的并发模型)
    - [事件循环](#事件循环)
  - [参考 Reference](#参考-reference)

进程、线程和协程这些概念的提出其实都或多或少为了允许计算机在有限的计算资源下能够同时执行多个任务，即并发地运行程序。也就是说，进程、线程、协程都是操作系统中重要的并发模型。

![图1 进程 vs 线程 vs 协程](https://blog.kennycoder.io/2020/05/16/%E9%80%B2%E7%A8%8B-Process-%E3%80%81%E7%B7%9A%E7%A8%8B-Thread-%E3%80%81%E5%8D%94%E7%A8%8B-Coroutine-%E7%9A%84%E6%A6%82%E5%BF%B5%E8%AC%9B%E8%A7%A3/cover.png)

比如，进程的提出就是为了互不干扰地为多个用户提供服务。从用户的角度来看，多进程通过CPU调度技术（CPU Scheduling）和进程地址空间（Process Address Space）使得计算和存储资源都得到了隔离和抽象。换句话说，进程就是CPU的虚拟化，地址空间就是内存的虚拟化。这也是贯穿操作系统的思想，即虚拟化，包括后续的文件/目录（块设备的虚拟化）也使用了这一思想。而线程则是进一步达成细粒度的并发执行，更高效地利用CPU。最后，协程则在线程的基础之上，再一次减少了上下文切换的开销。

**并发 vs 并行**：

并发是指任务的时间上的重叠执行。它可以容忍只有一个CPU资源，因为CPU可以分时间片交替执行，从而模拟出任务执行重叠的效果。而并行则是指一个或多个任务同时在多个CPU上真正同时执行。

## 进程 Process

**进程与程序**：

进程和程序组成了一对相依的概念。一个运行中的程序被称为一个进程；反过来讲，进程就是程序的一个实例。更准确的说，一个正在执行、且拥有独立的内存空间和资源的程序就是进程。

**进程与状态机**：

![图2 进程的状态](https://camo.githubusercontent.com/0398c2bace5b1b0695f5a34f6cfedf6e358db565408abc83dd161de71d3bfec8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f50726f6365737353746174652e706e67)

尽管我们说一个正在执行的程序是进程，但进程作为一个状态机，不光有正在执行（Running）的状态，它还具有如图2中所展示的其他状态，包括：

- 新建状态（Created/New）：等待资源分配
- 就绪状态（Ready）：等待CPU资源
- 阻塞状态（Waiting）：等待其他资源，如I/O等
- 中止状态（Terminated）：进程执行结束

**进程的标识**：

进程的描述符不是一个简单的符号，而是由多种信息（进程优先级、状态、虚拟地址以及访问权限等等）组成的一个复杂数据结构。而被保存在其中的进程ID（Process ID）则可以认为是进程在操作系统中的唯一标识。

### 进程API Process API

**fork()**：做一份状态机的完整复制（内存、寄存器现场）。

`pid_t fork(void)`

在fork函数返回后，会有两个进程同时运行，其中一个是父进程，另一个是新创建的子进程。

在子进程创建成功后，它会复制父进程的代码和数据段，并且开始执行从fork函数返回的位置。也就是说，子进程会从fork函数返回的地方开始执行，而不是从程序的起始位置开始执行。

需要注意的是，在子进程中，fork函数的返回值是0，而在父进程中，fork函数的返回值是新创建的子进程的进程ID。因此，在父进程中可以通过判断fork函数的返回值来区分当前进程是父进程还是子进程。

**execve()**：将当前运行的状态机重置成另一个程序的初始状态。

`int execve(const char *pathname, char *const argv[], char *const envp[]);`

- pathname：指定要执行的程序的路径，可以是绝对路径或者相对路径。如果路径中不包含目录分隔符 /，则会从环境变量 PATH 中查找可执行文件。
- argv：一个以 NULL 结尾的字符串数组，用于指定新程序的命令行参数。第一个元素通常是程序的名称，后面的元素是程序的参数。注意，第一个元素是程序的名称，而非路径名。
- envp：一个以 NULL 结尾的字符串数组，用于指定新程序的环境变量。每个字符串都是一个形如 key=value 的键值对，表示一个环境变量的值。

execve函数执行成功时，不会返回到调用进程，而是直接将当前进程替换为新程序的进程。如果执行失败，则会返回 -1，并设置相应的错误码。

### 进程的地址空间 Process Address Space

**提出背景**：

为了多个程序能同时驻留在内存且互不干扰地运行，操作系统使用虚拟内存技术提供了一种地址空间的机制（Address Space）来保证隔离性。通过地址空间，操作系统向上层应用屏蔽了实际代码存储细节，即完成了对内存的抽象。换句话说，进程空间就是程序能够看到的内存。

**空间组成**：

![图3 进程地址空间](https://gabrieletolomei.files.wordpress.com/2013/10/program_in_memory2.png)

一个进程的地址空间包含了程序的所有运行状态，如图3进程地址空间所示。它总体上可以分成两大部分，即用户空间和内核空间。其中，前者也就是实现进程隔离性的核心。而后者虽然是共享的（映射了同一段物理内存），但仅仅只有当进程需要执行系统调用，并切换到内核态之后才会真正访问。（有关内核空间这部分的相关知识会在进程调度章节中更详细说明。）

对于用户空间部分，它一般由以下几个部分组成：

- 代码区(存储程序代码)
- 全局数据区(存储全局变量和静态变量)
- 栈区(存储函数调用时创建的局部变量和参数)
- 堆区(存储动态分配的内存)

而对于内核空间，它则一般包含：

- 内核代码和数据
- 系统调用表
- 设备驱动
- 中断处理程序
- 进程描述符
- 缓冲区
- 设备寄存器虚拟映射表

### 进程间通信 IPC

在多进程程序中，各个程序的协作通常依靠`进程间通讯IPC(Interprocess Communication)`来完成。

**分类 Classification**：

Linux系统中，IPC被分成三大类：

- 基于数据的IPC方法
  - 匿名 & FIFO 管道
  - 消息队列
  - 共享内存
- 基于信号的IPC方法
  - IPC中唯一一种异步的通讯方法
- 基于同步的IPC方法
  - 信号量
  - 互斥量（一种特殊的信号量，只有锁定和非锁定两种状态）

**管道 Pipeline**：

**套接字 Socket**：

### 进程调度 Process Scheduling

尽管我们一再指出进程实现了CPU的虚拟化，即以某种方式让多个任务在某时段共享CPU，使它们看起来像是并发执行。这背后的基本思想就是时分共享（Time Sharing）CPU，但实现这种机制的前提则是如何实现进程的切换。换句话说，虚拟化CPU的前提是操作系统能够有效的运行进程，并保留部分CPU控制权以在恰当的时候进行进程的上下文切换。

因此，我会在这一部分讲一讲进程切换的底层机制和常见调度策略。

**CPU虚拟化的前提**：

进程在操作系统中是处于一种受限制直接执行（Limited Direct Execution）的模式之中的。其中，直接执行十分好理解，即程序直接作用于CPU。而受限制则是指进程默认处于用户模式（User Mode），无法访问一些硬件资源。只有当其使用陷入（Trap）内核指令切换到内核模式（Kernel Mode），才能访问机器的所有硬件资源。此外，操作系统还提供了一种陷阱返回（Return From Trap）指令来支持内核模式到用户模式的切换。

尽管操作系统通过用户和内核两种模式，使得进程在需要一些特殊硬件资源时，必须将CPU的控制权返还给操作系统，但这仅仅只能覆盖部分情况，当进程不需要访问硬件资源时，操作系统又该怎么做呢？答案是，利用时钟中断（Timer Interrupt）。当产生一个时钟中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序（Interrupt Handler）会运行。此时，操作系统重新获得CPU的控制权。这也就是操作系统进程切换的底层机制。

**上下文切换**：

上下文切换（Context Switch）在概念上很简单：操作系统要做的就是为当前正在执行的进程保存一些寄存器的值，并为即将执行的进程恢复一些寄存器的值。这样一来，操作系统就可以确保最后执行从陷阱返回指令时，不是返回到之前运行的进程，而是继续执行另一个进程。C语言中也提供了`setjmp`和`longjmp`这一对函数来实现上下文切换。

**进程调度的策略**：

- 先到先服务（First Come First Served）：按照请求的顺序进行调度。
- 最短任务优先（Shortest Job First）：按估计运行时间最短运行。但存在一直收到短时间任务，长时间任务永远得不到调度的情况。
- 最短剩余时间有限（Shortest Remaining Time Next）：最短任务优先的改进版本，按剩余运行时间的顺序进行调度。
- 轮转（Round-Robin）
  - 时间片轮转：所有就绪任务按注册时间排序，每次调度时，将CPU分配给队首任务，使其执行一个固定大小的时间片。算法效率和时间片的大小有很大关系。如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。而如果时间片过长，那么实时性就不能得到保证。
  - 优先级调度：为每个进程分配一个优先级，按优先级进行调度。

## 线程 Thread

**线程的标识**：

和进程类似，线程也有属于自己的ID（TID），但线程ID在系统范围内可以不是唯一的，它只在所属的进程范围内唯一。

**线程实现模型**：

线程的实现模型主要有3个，它们之间最大的区别就是与`内核调度实体KSE(Kernel Scheduling Entity)`的对应关系。顾名思义，内核调度实体就是可以被内核调度器调度的对象，也就是操作系统内核的最小调度单元。

- 用户级线程模型；用户级线程模型是由用户程序库提供的线程管理机制，内核不直接支持线程。在这种模型下，用户线程的创建、调度、同步、通信等操作都由用户程序库完成，内核只负责进程的管理和调度。用户级线程模型的优点是轻量级、灵活性高，但是缺点是无法利用多核处理器的优势，因为内核无法感知并发执行的用户线程。
- 内核级线程模型：内核级线程模型是由内核提供的线程管理机制，内核负责线程的创建、调度、同步、通信等操作。在这种模型下，每个线程都有对应的内核线程，内核可以感知并发执行的内核线程并进行调度。内核级线程模型的优点是能够充分利用多核处理器的优势，缺点是线程切换的开销较大，且线程同步和通信需要通过内核来完成，效率较低。
- 两级线程模型；：混合线程模型是用户级线程模型和内核级线程模型的结合，既可以利用用户级线程模型的轻量级和灵活性，又可以利用内核级线程模型的多核处理器优势。在混合线程模型下，每个进程可以有多个用户线程，由用户程序库进行管理，同时每个用户线程对应一个内核线程，由内核进行调度。当一个用户线程被阻塞时，它对应的内核线程可以继续执行其他用户线程，从而提高系统的并发能力和吞吐量。

### POSIX线程API

### 线程同步

- 共享内存
- 互斥量
- 条件变量

## 协程 Coroutine

协程与线程的区别在于协程是完全在应用程序内 (低特权运行级) 实现的，不需要操作系统的支持，占用的资源通常也比操作系统线程更小一些。协程可以随时切换执行流的特性，用于实现状态机、actor model, goroutine 等。

## 基于事件的并发模型

### 事件循环

## 参考 Reference

- [NJU-OS 操作系统上的进程](https://jyywiki.cn/OS/2022/slides/11.slides#/)
- [Operating Systems: Three Easy Pieces：Address Spaces](https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/13.pdf)
- [CSAPP: Computer System A Programmer's Perspective 第十二章 并发编程](https://hansimov.gitbook.io/csapp/part3/ch12-concurrent-programming)
- [Github Cyc2018/CS-Notes](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.md)
- [Process , Thread and Coroutines](https://www.linkedin.com/pulse/process-thread-coroutines-amit-nadiger/)

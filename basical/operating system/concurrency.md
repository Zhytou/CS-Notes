# 并发模型

- [并发模型](#并发模型)
  - [进程 Process](#进程-process)
    - [进程API Process API](#进程api-process-api)
    - [进程的地址空间 Process Address Space](#进程的地址空间-process-address-space)
    - [进程间通信 IPC](#进程间通信-ipc)
    - [进程调度 Process Scheduling](#进程调度-process-scheduling)
  - [线程 Thread](#线程-thread)
    - [POSIX线程API](#posix线程api)
    - [线程同步](#线程同步)
  - [协程 Coroutine](#协程-coroutine)
  - [基于事件的并发模型](#基于事件的并发模型)
    - [事件循环](#事件循环)
  - [参考 Reference](#参考-reference)

进程、线程和协程这些概念其实都或多或少是为了允许计算机在有限的计算资源下能够同时执行多个任务，即并发地运行程序。也就是说，进程、线程、协程都是操作系统中重要的并发模型。

比如，进程的提出就是为了互不干扰地为多个用户提供服务。从用户的角度来看，多进程通过CPU调度技术（CPU Scheduling）和进程地址空间（Process Address Space）使得计算和存储资源都得到了隔离和抽象。换句话说，进程就是CPU的虚拟化，地址空间就是内存的虚拟化。这也是贯穿操作系统的思想，即虚拟化，包括后续的文件/目录（块设备的虚拟化）也使用了这一思想。而线程则是进一步达成细粒度的并发执行，更高效地利用CPU。最后，协程则在线程的基础之上，再一次减少了上下文切换的开销。

**并发 vs 并行**：

并发是指任务的时间上的重叠执行。它可以容忍只有一个CPU资源，因为CPU可以分时间片交替执行，从而模拟出任务执行重叠的效果。而并行则是指一个或多个任务同时在多个CPU上真正同时执行。

## 进程 Process

**进程与程序**：

进程和程序组成了一对相依的概念。一个运行中的程序被称为一个进程；反过来讲，进程就是程序的一个实例。更准确的说，一个正在执行、且拥有独立的内存空间和资源的程序就是进程。

**进程与状态机**：

**进程的标识**：

进程的描述符不是一个简单的符号，而是由多种信息（进程优先级、状态、虚拟地址以及访问权限等等）组成的一个复杂数据结构。而被保存在其中的进程ID（Process ID）则可以认为是进程在操作系统中的唯一标识。

### 进程API Process API

**fork()**：做一份状态机的完整复制（内存、寄存器现场）。

`pid_t fork(void)`

在fork函数返回后，会有两个进程同时运行，其中一个是父进程，另一个是新创建的子进程。

在子进程创建成功后，它会复制父进程的代码和数据段，并且开始执行从fork函数返回的位置。也就是说，子进程会从fork函数返回的地方开始执行，而不是从程序的起始位置开始执行。

需要注意的是，在子进程中，fork函数的返回值是0，而在父进程中，fork函数的返回值是新创建的子进程的进程ID。因此，在父进程中可以通过判断fork函数的返回值来区分当前进程是父进程还是子进程。

**execve()**：将当前运行的状态机重置成另一个程序的初始状态。

`int execve(const char *pathname, char *const argv[], char *const envp[]);`

- pathname：指定要执行的程序的路径，可以是绝对路径或者相对路径。如果路径中不包含目录分隔符 /，则会从环境变量 PATH 中查找可执行文件。
- argv：一个以 NULL 结尾的字符串数组，用于指定新程序的命令行参数。第一个元素通常是程序的名称，后面的元素是程序的参数。注意，第一个元素是程序的名称，而非路径名。
- envp：一个以 NULL 结尾的字符串数组，用于指定新程序的环境变量。每个字符串都是一个形如 key=value 的键值对，表示一个环境变量的值。

execve函数执行成功时，不会返回到调用进程，而是直接将当前进程替换为新程序的进程。如果执行失败，则会返回 -1，并设置相应的错误码。

### 进程的地址空间 Process Address Space

**提出背景**：

为了多个程序能同时驻留在内存且互不干扰地运行，操作系统使用虚拟内存技术提供了一种地址空间的机制（Address Space）来保证隔离性。通过地址空间，操作系统向上层应用屏蔽了实际代码存储细节，即完成了对内存的抽象。换句话说，进程空间就是程序能够看到的内存。

**空间组成**：

![图1 进程地址空间](https://gabrieletolomei.files.wordpress.com/2013/10/program_in_memory2.png)

一个进程的地址空间包含了程序的所有运行状态，如图1进程地址空间所示。它总体上可以分成两大部分，即用户空间和内核空间。其中，前者也就是实现进程隔离性的核心。而后者虽然是共享的（映射了同一段物理内存），但仅仅只有当进程需要执行系统调用，并切换到内核态之后才会真正访问。

对于用户空间部分，它一般由以下几个部分组成：

- 代码区(存储程序代码)
- 全局数据区(存储全局变量和静态变量)
- 栈区(存储函数调用时创建的局部变量和参数)
- 堆区(存储动态分配的内存)

而对于内核空间，它则一般包含：

- 内核代码和数据
- 系统调用表
- 设备驱动
- 中断处理程序
- 进程描述符
- 缓冲区
- 设备寄存器虚拟映射表

### 进程间通信 IPC

在多进程程序中，各个程序的协作通常依靠`进程间通讯IPC(Interprocess Communication)`来完成。

**分类 Classification**：

Linux系统中，IPC被分成三大类：

- 基于数据的IPC方法
  - 匿名 & FIFO 管道
  - 消息队列
  - 共享内存
- 基于信号的IPC方法
  - IPC中唯一一种异步的通讯方法
- 基于同步的IPC方法
  - 信号量
  - 互斥量（一种特殊的信号量，只有锁定和非锁定两种状态）

**管道 Pipeline**：

**套接字 Socket**：

### 进程调度 Process Scheduling

## 线程 Thread

**线程的标识**：

和进程类似，线程也有属于自己的ID（TID），但线程ID在系统范围内可以不是唯一的，它只在所属的进程范围内唯一。

**线程实现模型**：

线程的实现模型主要有3个，它们之间最大的区别就是与`内核调度实体KSE(Kernel Scheduling Entity)`的对应关系。顾名思义，内核调度实体就是可以被内核调度器调度的对象，也就是操作系统内核的最小调度单元。

- 用户级线程模型；用户级线程模型是由用户程序库提供的线程管理机制，内核不直接支持线程。在这种模型下，用户线程的创建、调度、同步、通信等操作都由用户程序库完成，内核只负责进程的管理和调度。用户级线程模型的优点是轻量级、灵活性高，但是缺点是无法利用多核处理器的优势，因为内核无法感知并发执行的用户线程。
- 内核级线程模型：内核级线程模型是由内核提供的线程管理机制，内核负责线程的创建、调度、同步、通信等操作。在这种模型下，每个线程都有对应的内核线程，内核可以感知并发执行的内核线程并进行调度。内核级线程模型的优点是能够充分利用多核处理器的优势，缺点是线程切换的开销较大，且线程同步和通信需要通过内核来完成，效率较低。
- 两级线程模型；：混合线程模型是用户级线程模型和内核级线程模型的结合，既可以利用用户级线程模型的轻量级和灵活性，又可以利用内核级线程模型的多核处理器优势。在混合线程模型下，每个进程可以有多个用户线程，由用户程序库进行管理，同时每个用户线程对应一个内核线程，由内核进行调度。当一个用户线程被阻塞时，它对应的内核线程可以继续执行其他用户线程，从而提高系统的并发能力和吞吐量。

### POSIX线程API

### 线程同步

- 共享内存
- 互斥量
- 条件变量

## 协程 Coroutine

协程与线程的区别在于协程是完全在应用程序内 (低特权运行级) 实现的，不需要操作系统的支持，占用的资源通常也比操作系统线程更小一些。协程可以随时切换执行流的特性，用于实现状态机、actor model, goroutine 等。

## 基于事件的并发模型

### 事件循环

## 参考 Reference

- [NJU-OS 操作系统上的进程](https://jyywiki.cn/OS/2022/slides/11.slides#/)
- [Operating Systems: Three Easy Pieces：Address Spaces](https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/13.pdf)
- [CSAPP: Computer System A Programmer's Perspective 第十二章 并发编程](https://hansimov.gitbook.io/csapp/part3/ch12-concurrent-programming)
- [Process , Thread and Coroutines](https://www.linkedin.com/pulse/process-thread-coroutines-amit-nadiger/)

# 同步

## 锁

### 自旋锁 Spin Lock

自旋锁是一种基于忙等待的锁。

当一个线程需要获取自旋锁时，如果锁已经被占用，那么这个线程会一直忙等待，直到锁被释放。自旋锁的实现通常是基于原子操作的方式，当一个线程获取锁时，它会使用原子操作来修改锁的状态，以避免并发访问锁时的数据竞争问题。

**x86 LOCK指令前缀**：

x86的LOCK指令前缀是用于多处理器环境下实现原子操作（atomic operation）的机制。

使用带LOCK前缀的指令能实现多种原子操作，如：

- 原子交换：例如在实现Spinlock中的锁获取和释放操作时，可以使用XCHG指令和LOCK前缀来保证锁的原子性。
- 原子比较-交换：例如在实现无锁算法中，可以使用CMPXCHG指令和LOCK前缀来实现原子比较-交换操作。

**实现自旋锁**：

``` c++
// atomic exchange
int xchg(volatile int *addr, int newval) {
  int result;
  asm volatile ("lock xchg %0, %1"
    : "+m"(*addr), "=a"(result) : "1"(newval));
  return result;
}

int locked = 0;
void lock() { while (xchg(&locked, 1)) ; }
void unlock() { xchg(&locked, 0); }
```

**原子操作与Bus Lock**：

早期原子操作的实现依靠总线上锁来实现。具体如下，当一个处理器执行带有LOCK前缀的指令时，它会锁住内存总线，防止其他处理器同时对同一内存地址进行操作，从而确保了原子操作的正确性。

**原子操作的现代实现**：

现代处理器中，原子操作通常是通过硬件支持来实现的，它们能够保证对内存的原子操作，而不需要锁住总线或者使用其他的软件实现方式，从而提高了系统的性能和并发能力。

**C++支持的原子操作**：

详细信息可以阅读[cppreference](https://en.cppreference.com/w/cpp/atomic/atomic_exchange)。

**自旋锁的缺陷**：

- 自旋 (共享变量) 会触发处理器间的缓存同步，延迟增加；
- 除了进入临界区的线程，其他处理器上的线程都在空转，且争抢锁的处理器越多，利用率越低；
- 获得自旋锁的线程可能被操作系统切换出去。

**自旋锁适合的使用场景**：

- 临界区几乎不 “拥堵”；
- 持有自旋锁时禁止执行流切换。

换句话说，自旋锁适用于短临界区的场景，比如操作系统内核的并发数据结构。

### 互斥锁 Mutex

互斥锁（Mutex）是一种基于操作系统的同步原语，它使用了操作系统提供的系统调用来实现线程同步和互斥。

互斥锁的实现通常是基于一种叫做“睡眠-唤醒”机制的方式，当一个线程需要获取锁时，如果锁已经被占用，那么这个线程会被阻塞，直到锁被释放。当锁被释放时，操作系统会唤醒等待的线程，让它们竞争锁。

### 快速用户空间互斥锁 Futex

Futex（Fast Userspace Mutex）是一种基于用户空间的同步原语。实际上，就是Spinlock和Mutex的混合。

**Futex的上锁过程**：

- 先在用户空间自旋。
  - 如果获得锁，直接进入；
  - 未能获得锁，系统调用。
- 解锁以后也需要系统调用。

## 条件变量

## 信号量

## 信号

## 参考

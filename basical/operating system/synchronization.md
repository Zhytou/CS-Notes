# 同步

- [同步](#同步)
  - [锁](#锁)
    - [互斥锁 Mutex](#互斥锁-mutex)
    - [自旋锁 Spinlock](#自旋锁-spinlock)
    - [快速用户空间互斥锁 Futex](#快速用户空间互斥锁-futex)
    - [死锁 Deadlock](#死锁-deadlock)
  - [条件变量](#条件变量)
  - [信号量](#信号量)
  - [信号](#信号)
  - [参考](#参考)

## 锁

锁是一种计算机同步技术。它能通过限制共享资源的同时访问，来保证多个进程的同步执行。具体来说，在进入临界区段（Critical Section）之前，程序被要求获取锁，否则无法修改共享资源。在这样的机制下，任何时候只能有一个进程持有锁进入临界区。

> 在同步的程序设计中，临界区段或称为关键区块指的是一个访问共享资源的程序片段。

互斥锁和自旋锁是最常见的两种锁。其中，前者会使等待该锁的程序陷入内核而被阻塞，直到上一个持有锁的程序执行完毕之后，操作系统才会选择任意一个等待该锁的程序唤醒。相反的，后者不会使程序陷入内核态，而是让其不断询问锁是否可用，即：在用户态下自旋。换句话说，互斥锁会使程序将CPU的控制权交还给操作系统，而自旋锁则不会。

### 互斥锁 Mutex

互斥锁（Mutual Exclusion，Mutex）是一种基于操作系统的同步原语，它使用了操作系统提供的系统调用来实现线程同步和互斥。

**睡眠-唤醒**：

互斥锁的实现通常是基于一种叫做“睡眠-唤醒”机制的方式。当一个线程需要获取锁时，如果锁已经被占用，那么锁会通过系统调用如sleep等阻塞这个线程，直到上一个持有锁的程序执行完毕。当锁被释放时，操作系统会唤醒任意一个等待的线程，让它获得锁，直到该锁的等待队列为空时，释放掉锁。

**适用场景**：

这种会使等待锁的线程陷入内核的特点决定了互斥量在锁的所有权频繁切换场景下不会适用，因为频繁陷入内核会使线程（特别是跨进程的线程）上下文切换的成本过高。

### 自旋锁 Spinlock

自旋锁是一种基于忙等待和原子操作的锁。当一个程序需要获取自旋锁时，如果锁已经被占用，那么这个程序会一直忙等待，直到锁被释放。而当程序获取到锁时，它会使用原子操作来修改锁的状态，以避免并发访问锁时的数据竞争问题。

**x86 LOCK指令前缀**：

以x86架构的机器为例，它所支持的LOCK指令前缀就是用于实现原子操作（Atomic Operation）的机制，比如：

- 原子交换：例如在实现Spinlock中的锁获取和释放操作时，可以使用XCHG指令和LOCK前缀来保证锁的原子性。
- 原子比较-交换：例如在实现无锁算法中，可以使用CMPXCHG指令和LOCK前缀来实现原子比较-交换操作。

**实现自旋锁**：

``` c++
// atomic exchange
int xchg(volatile int *addr, int newval) {
  int result;
  asm volatile ("lock xchg %0, %1"
    : "+m"(*addr), "=a"(result) : "1"(newval));
  return result;
}

int locked = 0;
void lock() { while (xchg(&locked, 1)) ; }
void unlock() { xchg(&locked, 0); }
```

**原子操作与总线**：

早期原子操作的实现依靠总线上锁来实现。具体如下，当一个处理器执行带有LOCK前缀的指令时，它会锁住内存总线，防止其他处理器同时对同一内存地址进行操作，从而确保了原子操作的正确性。

**原子操作的现代实现**：

现代处理器中，原子操作通常是通过硬件支持来实现的，它们能够保证对内存的原子操作，而不需要锁住总线或者使用其他的软件实现方式，从而提高了系统的性能和并发能力。

**自旋锁的缺陷**：

- 自旋 (共享变量) 会触发处理器间的缓存同步，延迟增加；
- 除了进入临界区的线程，其他处理器上的线程都在空转，且争抢锁的处理器越多，利用率越低；
- 获得自旋锁的线程可能被操作系统切换出去。

**自旋锁适合的使用场景**：

- 临界区几乎不 “拥堵”；
- 持有自旋锁时禁止执行流切换。

换句话说，自旋锁适用于短临界区的场景，比如操作系统内核的并发数据结构。

### 快速用户空间互斥锁 Futex

Futex（Fast Userspace Mutex）是一种基于用户空间的同步原语。实际上，就是Spinlock和Mutex的混合。

**Futex的上锁过程**：

- 先在用户空间自旋。
  - 如果获得锁，直接进入；
  - 未能获得锁，系统调用。
- 解锁以后也需要系统调用。

### 死锁 Deadlock

- 互斥：一个资源每次只能被一个进程使用
- 请求与保持：一个进程请求资阻塞时，不释放已获得的资源
- 不剥夺：进程已获得的资源不能强行剥夺
- 循环等待：若干进程之间形成头尾相接的循环等待资源关系

## 条件变量

## 信号量

> 信号量和管程

## 信号

## 参考

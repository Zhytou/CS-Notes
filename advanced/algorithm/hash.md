# 哈希Hash

## 简介

### 概述

- 哈希函数 Hash Function
- 哈希表 Hash Table

### 作用

- 哈希与加密
- 一致性哈希与分布式

## 实战

[LRU实现](https://leetcode-cn.com/problems/lru-cache/)

## 问题

### Hash Collision 冲突

 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。

### Common Solution 解决

**开放定址**：

使用某种探测算法在散列表中寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到。

就是即使key产生冲突，也不会形成链表，而是将所有元素都存入哈希表里。发生冲突时，就以当前地址为基准，进行再寻址的方法去寻址下一个地址，直到找到一个为空的地址为止。

但这种方法存在一个问题，就是删除元素时，只能懒惰删除，即将该位置中元素标记为已删除。因为每个元素不仅关系到自己，还影响查找其他元素。

具体来说，寻找新地址的方法分为三种，分别是线性探查法、平方探查法和双散列函数探查法：

- 线性探测：顺序查找下一个位置，直到找到一个空位置（固定步长1探测）。
- 二次探测：在表的左右位置进行按一定步长跳跃式探测（固定步长n探测）。
- 伪随机探测：根据公式生成一个随机数，作为此次探测空位置的步长（随机步长n探测）。

**链地址法(开链)**：

链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。

**再哈希法**：

就是同时构造多个不同的哈希函数。

这种方法不易产生聚集，但是增加了计算时间。

**建立公共溢出区**：

将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。

## 参考

**综合**：

- [wiki - hash](https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8)

- [wiki - hash table](https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8)

**冲突解决**：

- [解决哈希冲突的常用方法分析](https://cloud.tencent.com/developer/article/1672781)

**渐进式哈希**：

- [美团技术博客](https://tech.meituan.com/2018/07/27/redis-rehash-practice-optimization.html)
